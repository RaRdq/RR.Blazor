@** 
<summary>
Tab container for organizing content with smooth animations.
</summary>
<category>Navigation</category>
<complexity>Complex</complexity>
<ai-prompt>Create tabs for content organization</ai-prompt>
<ai-common-use>dashboards, forms, data views, settings panels</ai-common-use>
<ai-avoid>Don't use for navigation breadcrumbs - use RBreadcrumbs instead</ai-avoid>
**@
@using RR.Blazor.Enums
@using RR.Blazor.Attributes
@using RR.Blazor.Components
@using RR.Blazor.Components.Base
@using RR.Blazor.Components.Display
@using RR.Blazor.Components.Feedback
@using RR.Blazor.Utilities
@inherits RSizedComponentBase<SizeType>
@implements IDisposable

@attribute [Component("RTabs", Category = "Navigation", Complexity = ComponentComplexity.Complex)]
@attribute [AIOptimized(Prompt = "Create professional tabs for content organization", 
                       CommonUse = "dashboards, forms, data views, settings panels", 
                       AvoidUsage = "Don't use for navigation breadcrumbs - use RBreadcrumbs instead")]

<CascadingValue Value="@this">
    @ChildContent
    
    <div @ref="tabsElement" class="tabs @GetTabsClasses()" @attributes="GetSafeAttributes()">
        @if (tabs.Count == 0)
        {
            <REmptyState Icon="tab" 
                         Text="@($"No tabs available ({tabs.Count} tabs registered)")" 
                         Description="@($"This tab container has no content to display. Debug: {(ChildContent != null ? "Has ChildContent" : "No ChildContent")}")" />
        }
        else
        {
        <!-- Tab Navigation with Scroll Arrows -->
        <nav class="@GetNavClasses()" role="tablist" aria-label="@AriaLabel">
        <!-- Left Scroll Arrow -->
        <button type="button" 
                class="tabs-nav-arrow tabs-nav-arrow-left @GetLeftArrowClasses()"
                @onclick="ScrollLeft"
                aria-label="@(Orientation == Orientation.Vertical ? "Scroll tabs up" : "Scroll tabs left")">
            <i class="icon">@(Orientation == Orientation.Vertical ? "keyboard_arrow_up" : "chevron_left")</i>
        </button>
        
        <!-- Scrollable Tab Container -->
        <div class="tabs-nav-container" @ref="navContainer">
            <div class="tabs-nav-wrapper" @ref="navWrapper">
                <!-- Animated Indicator -->
                @if (Variant != TabsVariant.Card)
                {
                    <div class="tabs-indicator" style="@GetIndicatorStyle()"></div>
                }
                
                <!-- Tab Headers -->
                @foreach (var tab in tabs)
                {
                    @if (ShowTooltips && !string.IsNullOrEmpty(tab.Tooltip))
                    {
                        <RTooltip Content="@tab.Tooltip" Position="TooltipPosition.Bottom" Size="SizeType.Small">
                            <button type="button"
                                    id="tab-@tab.Id"
                                    class="@GetTabClasses(tab)"
                                    role="tab"
                                    aria-selected="@(tab.Id == ActiveTabId)"
                                    aria-controls="panel-@tab.Id"
                                    aria-label="@(!string.IsNullOrEmpty(tab.AriaLabel) ? tab.AriaLabel : tab.Text)"
                                    tabindex="@(tab.Id == ActiveTabId ? 0 : -1)"
                                    disabled="@tab.Disabled"
                                    @onclick="() => !tab.Disabled ? SelectTab(tab.Id) : Task.CompletedTask"
                                    @onkeydown="@(e => HandleKeyDown(e, tab.Id))">
                                @GetTabContentFragment(tab)
                            </button>
                        </RTooltip>
                    }
                    else
                    {
                        <button type="button"
                                id="tab-@tab.Id"
                                class="@GetTabClasses(tab)"
                                role="tab"
                                aria-selected="@(tab.Id == ActiveTabId)"
                                aria-controls="panel-@tab.Id"
                                aria-label="@(!string.IsNullOrEmpty(tab.AriaLabel) ? tab.AriaLabel : tab.Text)"
                                tabindex="@(tab.Id == ActiveTabId ? 0 : -1)"
                                disabled="@tab.Disabled"
                                @onclick="() => !tab.Disabled ? SelectTab(tab.Id) : Task.CompletedTask"
                                @onkeydown="@(e => HandleKeyDown(e, tab.Id))">
                            @GetTabContentFragment(tab)
                        </button>
                    }
                }
                
                <!-- Add Tab Button -->
                @if (ShowAddButton)
                {
                    <button type="button" 
                            class="touch-target px-3 py-2 rounded-md hover-lift-sm transition-all border border-dashed border-secondary"
                            @onclick="HandleAddTab">
                        <i class="icon text-sm">add</i>
                    </button>
                }
            </div>
        </div>
        
        <!-- Right Scroll Arrow -->
        <button type="button" 
                class="tabs-nav-arrow tabs-nav-arrow-right @GetRightArrowClasses()"
                @onclick="ScrollRight"
                aria-label="@(Orientation == Orientation.Vertical ? "Scroll tabs down" : "Scroll tabs right")">
            <i class="icon">@(Orientation == Orientation.Vertical ? "keyboard_arrow_down" : "chevron_right")</i>
        </button>
    </nav>
    
        <!-- Tab Content -->
        <div class="@GetContentClasses()">
            @foreach (var tab in tabs)
            {
                @if (KeepPanelsAlive || tab.Id == ActiveTabId)
                {
                    <div id="panel-@tab.Id"
                         class="tabs-panel @(tab.Id == ActiveTabId ? "tabs-panel-active" : "") @(FadeOnly || !ShowAnimation ? "tabs-panel-fade-only" : "")"
                         role="tabpanel"
                         aria-labelledby="tab-@tab.Id"
                         tabindex="0"
                         style="@(!KeepPanelsAlive && tab.Id != ActiveTabId ? "display: none;" : "")">
                        @if (Loading && tab.Id == ActiveTabId)
                        {
                            <RSkeleton Loading="true" Type="SkeletonType.Card">
                                @tab.Content
                            </RSkeleton>
                        }
                        else
                        {
                            @tab.Content
                        }
                    </div>
                }
            }
        </div>
        }
    </div>
</CascadingValue>

@code {
    /// <summary>Tab variant style</summary>
    [Parameter, AIParameter("Visual style of tabs", "TabsVariant.Default, TabsVariant.Pills, TabsVariant.Card")] 
    public TabsVariant Variant { get; set; } = TabsVariant.Default;
    
    /// <summary>Tab orientation</summary>
    [Parameter, AIParameter("Orientation of tabs", "Orientation.Horizontal, Orientation.Vertical")]
    public Orientation Orientation { get; set; } = Orientation.Horizontal;
    
    /// <summary>Active tab ID</summary>
    [Parameter, AIParameter("ID of currently active tab", "Use with @bind-ActiveTabId for two-way binding")] 
    public string ActiveTabId { get; set; }
    
    /// <summary>Callback when active tab changes</summary>
    [Parameter] public EventCallback<string> ActiveTabIdChanged { get; set; }
    
    /// <summary>Selected tab for two-way binding (alias for ActiveTabId)</summary>
    [Parameter, AIParameter("ID of currently selected tab", "Use with @bind-SelectedTab for two-way binding")] 
    public string SelectedTab 
    { 
        get => ActiveTabId; 
        set => ActiveTabId = value; 
    }
    
    /// <summary>Callback when selected tab changes</summary>
    [Parameter] public EventCallback<string> SelectedTabChanged { get; set; }
    
    /// <summary>Whether to show add tab button</summary>
    [Parameter, AIParameter("Show + button for adding new tabs", "true for dynamic tab creation")] 
    public bool ShowAddButton { get; set; }
    
    
    /// <summary>Whether tab content has no padding</summary>
    [Parameter, AIParameter("Remove padding from tab content area", "true for full-width content like tables")] 
    public bool NoPadding { get; set; }
    
    /// <summary>Use fade only animation (no slide)</summary>
    [Parameter] public bool FadeOnly { get; set; }
    
    /// <summary>Show tooltips on tab headers</summary>
    [Parameter, AIParameter("Enable tooltips on tab headers", "true to show tooltips, false to hide")] 
    public bool ShowTooltips { get; set; } = true;
    
    /// <summary>Enable animations for tab transitions</summary>
    [Parameter, AIParameter("Enable smooth tab transition animations", "true for animations, false for instant transitions")] 
    public bool ShowAnimation { get; set; } = true;
    
    /// <summary>Whether to show badges on tabs</summary>
    [Parameter, AIParameter("Show badges on tab headers", "true to display badges, false to hide")] 
    public bool ShowBadges { get; set; } = true;
    
    
    /// <summary>Whether to keep all tab panels alive (renders all content, disables lazy loading)</summary>
    [Parameter, AIParameter("Keep all tab panels alive in DOM", "false for lazy loading (performance), true to keep all panels rendered")] 
    public bool KeepPanelsAlive { get; set; } = false;
    
    
    
    
    /// <summary>Called when tab selection changes</summary>
    [Parameter] public EventCallback<TabChangedEventArgs> OnTabChanged { get; set; }
    
    /// <summary>Called when add tab button is clicked</summary>
    [Parameter] public EventCallback OnAddTab { get; set; }
    
    /// <summary>Called when tab close button is clicked</summary>
    [Parameter] public EventCallback<TabClosedEventArgs> OnTabClosed { get; set; }
    
    
    private readonly List<RTabItemInfo> tabs = new();
    private ElementReference tabsElement;
    private ElementReference navContainer;
    private ElementReference navWrapper;
    private double indicatorLeft = 0;
    private double indicatorWidth = 0;
    private bool isScrollable = false;
    private bool canScrollLeft = false;
    private bool canScrollRight = false;
    private bool canScrollUp = false;
    private bool canScrollDown = false;
    private bool isUpdatingIndicator = false;
    private bool isUpdatingScrollState = false;
    private bool wasActiveTabIdSetExternally = false;
    
    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Track if ActiveTabId was set externally (from parameter)
        wasActiveTabIdSetExternally = !string.IsNullOrEmpty(ActiveTabId);
    }
    
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        var currentActiveTab = tabs.FirstOrDefault(t => t.Id == ActiveTabId);
        
        if (!string.IsNullOrEmpty(ActiveTabId) && currentActiveTab != null)
        {
            wasActiveTabIdSetExternally = true;
            StateHasChanged();
        }
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                await SafeInvokeAsync("RRBlazor.Tabs.initializeTabs", tabsElement, navContainer, navWrapper, Orientation == Orientation.Vertical ? "vertical" : "horizontal");
                
                if (tabs.Count > 0)
                {
                    await UpdateIndicatorPosition();
                    await Task.Yield();
                    await UpdateScrollState();
                }
            }
            catch
            {
                // Silently handle initialization errors
            }
        }
        else if (tabs.Count > 0 && !isUpdatingIndicator && !isUpdatingScrollState)
        {
            // Only update scroll state when not already updating to prevent render loops
            _ = InvokeAsync(async () =>
            {
                try
                {
                    await Task.Yield(); // Let Blazor render
                    if (!isUpdatingIndicator && !isUpdatingScrollState) // Double-check to prevent race conditions
                    {
                        await UpdateScrollState();
                    }
                }
                catch
                {
                    // Silently handle update errors
                }
            });
        }
    }
    
    public void AddTab(RTabItemInfo tab)
    {
        if (tab == null) return;
        
        var existingTab = tabs.FirstOrDefault(t => t.Id == tab.Id);
        if (existingTab != null)
        {
            existingTab.Text = tab.Text;
            existingTab.Icon = tab.Icon;
            existingTab.IconPosition = tab.IconPosition;
            existingTab.Disabled = tab.Disabled;
            existingTab.Closable = tab.Closable;
            existingTab.Badge = tab.Badge;
            existingTab.BadgeCount = tab.BadgeCount;
            existingTab.BadgeVariant = tab.BadgeVariant;
            existingTab.Content = tab.Content;
        }
        else
        {
            tabs.Add(tab);
        }
        
        if (string.IsNullOrEmpty(ActiveTabId) && tabs.Count == 1)
        {
            ActiveTabId = tabs[0].Id;
        }
        else if (!string.IsNullOrEmpty(ActiveTabId) && tab.Id == ActiveTabId)
        {
            wasActiveTabIdSetExternally = true;
        }
        
        StateHasChanged();
        
        // Debounce updates to prevent render loops - multiple attempts to ensure scroll detection works
        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(50); // Let DOM update
                await InvokeAsync(async () => 
                {
                    await UpdateScrollState();
                    await UpdateIndicatorPosition();
                });
                
                // Additional delayed update for reliable detection
                await Task.Delay(200);
                await InvokeAsync(async () => 
                {
                    await UpdateScrollState();
                });
            }
            catch (Exception ex)
            {
                // Silently handle error
            }
        });
    }
    
    public List<RTabItemInfo> GetTabs()
    {
        return tabs;
    }
    
    public void RemoveTab(string tabId)
    {
        var tab = tabs.FirstOrDefault(t => t.Id == tabId);
        if (tab != null)
        {
            tabs.Remove(tab);
            

            if (ActiveTabId == tabId && tabs.Any())
            {
                var index = tabs.FindIndex(t => t.Id == tabId);
                if (index > 0)
                {
                    ActiveTabId = tabs[index - 1].Id;
                }
                else if (tabs.Any())
                {
                    ActiveTabId = tabs[0].Id;
                }
            }
            
            StateHasChanged();
        }
    }
    
    public void RemoveLastTab()
    {
        if (tabs.Any())
        {
            var lastTab = tabs.Last();
            RemoveTab(lastTab.Id);
        }
    }
    
    private async Task SelectTab(string tabId)
    {
        if (tabId == ActiveTabId) return;
        
        // Check if the tab is disabled
        var targetTab = tabs.FirstOrDefault(t => t.Id == tabId);
        if (targetTab?.Disabled == true) return;
        
        var oldTabId = ActiveTabId;
        
        // Update the ActiveTabId immediately
        ActiveTabId = tabId;
        wasActiveTabIdSetExternally = true; // Mark as set so it won't be overridden
        
        // Invoke the two-way binding callbacks IMMEDIATELY for proper data binding
        if (ActiveTabIdChanged.HasDelegate)
        {
            await ActiveTabIdChanged.InvokeAsync(ActiveTabId);
        }
        
        if (SelectedTabChanged.HasDelegate)
        {
            await SelectedTabChanged.InvokeAsync(ActiveTabId);
        }
        
        // Trigger state change after binding update
        StateHasChanged();
        
        // Invoke tab changed event
        if (OnTabChanged.HasDelegate)
        {
            await OnTabChanged.InvokeAsync(new TabChangedEventArgs
            {
                OldTabId = oldTabId,
                NewTabId = ActiveTabId
            });
        }
        
        // Update visual elements asynchronously to avoid blocking
        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Yield(); // Let DOM update
                await InvokeAsync(async () =>
                {
                    await ScrollToTab(tabId);
                    await UpdateIndicatorPosition();
                });
            }
            catch
            {
                // Silently handle visual update errors
            }
        });
    }
    
    private async Task CloseTab(string tabId)
    {
        await OnTabClosed.InvokeAsync(new TabClosedEventArgs { TabId = tabId });
        RemoveTab(tabId);
    }
    
    private async Task HandleAddTab()
    {
        await OnAddTab.InvokeAsync();
    }
    
    private async Task HandleKeyDown(KeyboardEventArgs e, string tabId)
    {
        switch (e.Key)
        {
            case "ArrowLeft":
                await NavigateTab(-1);
                break;
            case "ArrowRight":
                await NavigateTab(1);
                break;
            case "Home":
                if (tabs.Any())
                {
                    await SelectTab(tabs.First().Id);
                }
                break;
            case "End":
                if (tabs.Any())
                {
                    await SelectTab(tabs.Last().Id);
                }
                break;
            case "Delete":
                if (tabs.FirstOrDefault(t => t.Id == tabId)?.Closable == true)
                {
                    await CloseTab(tabId);
                }
                break;
        }
    }
    
    private async Task NavigateTab(int direction)
    {
        var currentIndex = tabs.FindIndex(t => t.Id == ActiveTabId);
        if (currentIndex >= 0)
        {
            var newIndex = currentIndex + direction;
            if (newIndex >= 0 && newIndex < tabs.Count)
            {
                await SelectTab(tabs[newIndex].Id);
            }
        }
    }
    
    private async Task UpdateIndicatorPosition()
    {
        if (string.IsNullOrEmpty(ActiveTabId) || Variant == TabsVariant.Card || isUpdatingIndicator)
            return;
            
        try
        {
            isUpdatingIndicator = true;
            
            var activeTab = tabs.FirstOrDefault(t => t.Id == ActiveTabId);
            if (activeTab != null)
            {
                var result = await SafeInvokeAsync<TabIndicatorPosition>("RRBlazor.Tabs.getTabIndicatorPosition", $"tab-{ActiveTabId}", navWrapper);
                
                // Only update if values have actually changed to prevent unnecessary re-renders
                if (Math.Abs(indicatorLeft - result.Left) > 0.5 || Math.Abs(indicatorWidth - result.Width) > 0.5)
                {
                    indicatorLeft = result.Left;
                    indicatorWidth = result.Width;
                    StateHasChanged();
                }
            }
        }
        catch
        {
        }
        finally
        {
            isUpdatingIndicator = false;
        }
    }
    
    private async Task UpdateScrollState()
    {
        if (isUpdatingScrollState) return; // Prevent concurrent updates
        
        try
        {
            isUpdatingScrollState = true;
            
            // Always check for scroll state regardless of tab count - even one wide tab can overflow
            var scrollInfo = await SafeInvokeAsync<ScrollInfo>("RRBlazor.Tabs.getTabScrollInfo", navWrapper, Orientation == Orientation.Vertical ? "vertical" : "horizontal");
            
            // Scroll state updated successfully

            bool stateChanged = false;
            
            if (isScrollable != scrollInfo.IsScrollable)
            {
                isScrollable = scrollInfo.IsScrollable;
                stateChanged = true;
            }
            
            if (Orientation == Orientation.Vertical)
            {
                if (canScrollUp != scrollInfo.CanScrollUp || canScrollDown != scrollInfo.CanScrollDown)
                {
                    canScrollUp = scrollInfo.CanScrollUp;
                    canScrollDown = scrollInfo.CanScrollDown;
                    stateChanged = true;
                }
            }
            else
            {
                if (canScrollLeft != scrollInfo.CanScrollLeft || canScrollRight != scrollInfo.CanScrollRight)
                {
                    canScrollLeft = scrollInfo.CanScrollLeft;
                    canScrollRight = scrollInfo.CanScrollRight;
                    stateChanged = true;
                }
            }
            
            if (stateChanged)
            {
                StateHasChanged();
                // State has changed, UI will update
            }
        }
        catch (Exception ex)
        {
            // Silently handle scroll state error
            // Reset scroll state on error but keep existing state if was working
            bool shouldReset = isScrollable || canScrollLeft || canScrollRight || canScrollUp || canScrollDown;
            if (shouldReset)
            {
                isScrollable = false;
                canScrollLeft = false;
                canScrollRight = false;
                canScrollUp = false;
                canScrollDown = false;
                StateHasChanged();
            }
        }
        finally
        {
            isUpdatingScrollState = false;
        }
    }
    
    private async Task ScrollLeft()
    {
        try
        {
            if (Orientation == Orientation.Vertical)
            {
                await SafeInvokeAsync("RRBlazor.Tabs.scrollTabsUp", navWrapper);
            } else {
                await SafeInvokeAsync("RRBlazor.Tabs.scrollTabsLeft", navWrapper);
            }
            await UpdateScrollState();
        }
        catch
        {
        }
    }
    
    private async Task ScrollRight()
    {
        try
        {
            if (Orientation == Orientation.Vertical)
            {
                await SafeInvokeAsync("RRBlazor.Tabs.scrollTabsDown", navWrapper);
            } else {
                await SafeInvokeAsync("RRBlazor.Tabs.scrollTabsRight", navWrapper);
            }
            await UpdateScrollState();
        }
        catch
        {
        }
    }
    
    private async Task ScrollToTab(string tabId)
    {
        try
        {
            await SafeInvokeAsync("RRBlazor.Tabs.scrollToTab", navWrapper, $"tab-{tabId}", Orientation == Orientation.Vertical ? "vertical" : "horizontal");
            await UpdateScrollState();
        }
        catch
        {
        }
    }
    
    private string GetTabClasses(RTabItemInfo tab)
    {
        var classes = new List<string>();
        
        classes.Add("tabs-tab");
        
        // Apply Size and Density separately - they are orthogonal concerns
        var sizeClasses = GetTabSizeClasses();
        var densityClasses = GetTabDensityClasses();
        
        // Split and add individual classes since these methods return space-separated strings
        if (!string.IsNullOrEmpty(sizeClasses))
            classes.AddRange(sizeClasses.Split(' ', StringSplitOptions.RemoveEmptyEntries));
        if (!string.IsNullOrEmpty(densityClasses))
            classes.AddRange(densityClasses.Split(' ', StringSplitOptions.RemoveEmptyEntries));
        
        if (tab.Id == ActiveTabId)
        {
            classes.Add("tabs-tab-active tab-active");
        }
        // Hover and inactive states are handled by CSS
        
        if (tab.Disabled)
        {
            classes.Add("state-disabled");
        }
        
        if (tab.Loading)
        {
            // Don't add CSS loading class to avoid double spinner - handled by icon only
            classes.Add("tabs-tab-has-loading");  // Use semantic class for styling without animation
        }
        
        if (tab.HasError)
        {
            classes.Add("tabs-tab-error state-error");
        }
        
        if (tab.Closable)
        {
            classes.Add("tabs-tab-closable");
        }
        
        return string.Join(" ", classes.Where(c => !string.IsNullOrEmpty(c)));
    }

    private string GetTabSizeClasses()
    {
        // Size-only properties (font size, icon size, min-height)
        var textClass = SizeHelper.GetTextSize(Size, Density);
        var minHeight = Size switch
        {
            SizeType.ExtraSmall => "min-h-8",
            SizeType.Small => "min-h-9",
            SizeType.Medium => "min-h-10",
            SizeType.Large => "min-h-11",
            SizeType.ExtraLarge => "min-h-12",
            _ => "min-h-10"
        };
        
        return $"{textClass} {minHeight}";
    }
    
    private string GetTabDensityClasses()
    {
        // Density-only properties (padding, margin, gap)
        var gap = DensityHelper.GetGap(Density);
        var hPadding = DensityHelper.GetHorizontalPadding(Density, "4");
        var vPadding = DensityHelper.GetVerticalPadding(Density, "3");
        var paddingClass = $"px-{hPadding} py-{vPadding}";
        
        return $"{paddingClass} gap-{gap}";
    }
    
    private string GetTabIconSize()
    {
        return SizeHelper.GetIconSize(Size, Density);
    }
    
    
    private string GetBadgeVariant(string variant) => variant switch
    {
        "error" => "tabs-tab-badge-error",
        "warning" => "tabs-tab-badge-warning", 
        "success" => "tabs-tab-badge-success",
        _ => ""
    };
    
    private string GetIndicatorStyle()
    {
        if (Orientation == Orientation.Vertical)
        {
            // For vertical tabs, use top and height instead of left and width
            return $"--indicator-top: {indicatorLeft.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)}px; --indicator-height: {indicatorWidth.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)}px;";
        }
        return $"--indicator-left: {indicatorLeft.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)}px; --indicator-width: {indicatorWidth.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)}px;";
    }
    
    private string GetTabsClasses()
    {
        var classes = new List<string> { "tabs d-flex w-full" };
        
        // Add size classes - following SRP, Size determines font sizes, icon sizes, component height
        var sizeClasses = GetSizeClasses();
        if (!string.IsNullOrEmpty(sizeClasses))
            classes.Add(sizeClasses);
        
        // Add density class - following SRP, Density determines spacing, padding, margins
        classes.Add(DensityHelper.BuildDensityClasses("tabs", Density));
        
        // Add orientation class
        if (Orientation == Orientation.Vertical)
        {
            classes.Add("tabs-vertical");
        }
        
        // Add variant-specific classes
        var variantClass = Variant switch
        {
            TabsVariant.Pills => "tabs-pills",
            TabsVariant.Card => "tabs-card",
            TabsVariant.Underline => "tabs-underline", 
            TabsVariant.Elevated => "tabs-elevated",
            TabsVariant.Segment => "tabs-segment",
            _ => "tabs-default"
        };
        classes.Add(variantClass);
        
        if (!string.IsNullOrEmpty(Class))
            classes.Add(Class);
            
        return string.Join(" ", classes);
    }
    
    private string GetNavClasses()
    {
        var classes = new List<string> { "tabs-nav" };
        
        // The variant-specific styling is handled by CSS, just add the base class
        return string.Join(" ", classes);
    }
    
    private string GetContentClasses()
    {
        var classes = new List<string> { "tabs-content" };
        
        if (!NoPadding)
        {
            // Padding is handled by CSS variants
        }
        else
        {
            classes.Add("tabs-content-no-padding");
        }
        
        // Variant-specific styling is handled by CSS
        return string.Join(" ", classes);
    }
    
    private string GetScrollArrowClasses(bool canScroll)
    {
        var classes = new List<string>();
        
        if (canScroll && isScrollable)
        {
            classes.Add("tabs-nav-arrow-visible");
        }
        
        return string.Join(" ", classes);
    }
    
    private string GetLeftArrowClasses()
    {
        return GetScrollArrowClasses(Orientation == Orientation.Vertical ? canScrollUp : canScrollLeft);
    }
    
    private string GetRightArrowClasses()
    {
        return GetScrollArrowClasses(Orientation == Orientation.Vertical ? canScrollDown : canScrollRight);
    }
    
    protected override string GetSizeClasses()
    {
        return Size switch
        {
            SizeType.ExtraSmall => "tabs-xs",
            SizeType.Small => "tabs-sm",
            SizeType.Medium => "tabs-md",
            SizeType.Large => "tabs-lg",
            SizeType.ExtraLarge => "tabs-xl",
            _ => "tabs-md"
        };
    }
    
    protected override SizeType GetDefaultSize() => SizeType.Medium;
    
    private RenderFragment GetTabContentFragment(RTabItemInfo tab) => builder =>
    {
        var seq = 0;
        
        // Show icon with loading/error state overlay or standalone icon
        if (!string.IsNullOrEmpty(tab.Icon) && tab.IconPosition == IconPosition.Start)
        {
            if (tab.Loading)
            {
                // Show loading spinner using proper loading system
                builder.OpenElement(seq++, "span");
                builder.AddAttribute(seq++, "class", "loading-spinner loading-spinner-inline");
                builder.CloseElement();
            }
            else if (tab.HasError)
            {
                // Show error icon instead of original icon
                builder.OpenElement(seq++, "i");
                builder.AddAttribute(seq++, "class", $"icon text-error {GetTabIconSize()}");
                builder.AddContent(seq++, "error");
                builder.CloseElement();
            }
            else
            {
                // Normal icon
                builder.OpenElement(seq++, "i");
                builder.AddAttribute(seq++, "class", $"icon {GetTabIconSize()}");
                builder.AddContent(seq++, tab.Icon);
                builder.CloseElement();
            }
        }
        else if (tab.Loading)
        {
            // Loading state without original icon
            builder.OpenElement(seq++, "span");
            builder.AddAttribute(seq++, "class", "loading-spinner loading-spinner-inline");
            builder.CloseElement();
        }
        else if (tab.HasError)
        {
            // Error state without original icon
            builder.OpenElement(seq++, "i");
            builder.AddAttribute(seq++, "class", $"icon text-error {GetTabIconSize()}");
            builder.AddContent(seq++, "error");
            builder.CloseElement();
        }
        
        if (!string.IsNullOrEmpty(tab.Text))
        {
            builder.OpenElement(seq++, "span");
            builder.AddContent(seq++, tab.Text);
            builder.CloseElement();
        }
        
        // Show badge if ShowBadges is true and tab has badge data
        if (ShowBadges)
        {
            if (tab.BadgeCount > 0)
            {
                builder.OpenElement(seq++, "span");
                builder.AddAttribute(seq++, "class", $"tabs-tab-badge {GetBadgeVariant(tab.BadgeVariant)}");
                builder.AddContent(seq++, tab.BadgeCount > 99 ? "99+" : tab.BadgeCount.ToString());
                builder.CloseElement();
            }
            else if (!string.IsNullOrEmpty(tab.Badge))
            {
                // Support string badges too
                builder.OpenElement(seq++, "span");
                builder.AddAttribute(seq++, "class", $"tabs-tab-badge {GetBadgeVariant(tab.BadgeVariant)}");
                builder.AddContent(seq++, tab.Badge);
                builder.CloseElement();
            }
        }
        
        if (!string.IsNullOrEmpty(tab.Icon) && tab.IconPosition == IconPosition.End)
        {
            builder.OpenElement(seq++, "i");
            builder.AddAttribute(seq++, "class", $"icon {GetTabIconSize()}");
            builder.AddContent(seq++, tab.Icon);
            builder.CloseElement();
        }
        
        if (tab.Closable)
        {
            builder.OpenElement(seq++, "button");
            builder.AddAttribute(seq++, "type", "button");
            builder.AddAttribute(seq++, "class", "tabs-tab-close");
            builder.AddAttribute(seq++, "onclick", EventCallback.Factory.Create(this, () => CloseTab(tab.Id)));
            builder.AddEventStopPropagationAttribute(seq++, "onclick", true);
            builder.OpenElement(seq++, "i");
            builder.AddAttribute(seq++, "class", "icon text-xs");
            builder.AddContent(seq++, "close");
            builder.CloseElement();
            builder.CloseElement();
        }
    };
    
    public class RTabItemInfo
    {
        public string Id { get; set; } = $"tab-{Guid.NewGuid():N}";
        public string Text { get; set; }
        public string Icon { get; set; }
        public IconPosition IconPosition { get; set; } = IconPosition.Start;
        public bool Disabled { get; set; }
        public bool Loading { get; set; }
        public bool HasError { get; set; }
        public bool Closable { get; set; }
        public string Badge { get; set; }  // Support string badges
        public int BadgeCount { get; set; }
        public string BadgeVariant { get; set; }
        public string AriaLabel { get; set; }
        public string Tooltip { get; set; }
        public RenderFragment Content { get; set; }
    }
    
    public class TabChangedEventArgs
    {
        public string OldTabId { get; set; }
        public string NewTabId { get; set; }
    }
    
    public class TabClosedEventArgs
    {
        public string TabId { get; set; } = "";
    }
    
    private class TabIndicatorPosition
    {
        public double Left { get; set; }
        public double Width { get; set; }
    }
    
    private class ScrollInfo
    {
        public bool IsScrollable { get; set; }
        public bool CanScrollLeft { get; set; }
        public bool CanScrollRight { get; set; }
        public bool CanScrollUp { get; set; }
        public bool CanScrollDown { get; set; }
    }
}


