@** 
<summary>
Professional tab container for organizing content with smooth animations and enterprise styling.
Supports multiple variants, badges, closable tabs, keyboard navigation, and accessibility.
</summary>
<category>Navigation</category>
<complexity>Complex</complexity>
<ai-prompt>Create professional tabs for content organization</ai-prompt>
<ai-common-use>dashboards, forms, data views, settings panels, multi-step workflows</ai-common-use>
<ai-avoid>Don't use for navigation breadcrumbs - use RBreadcrumbs instead. Avoid for simple toggles.</ai-avoid>
<ai-pattern name="basic-tabs">RTabs with RTabItem children for content organization</ai-pattern>
<ai-pattern name="pills-tabs">Variant="TabsVariant.Pills" for compact tab layouts</ai-pattern>
<ai-pattern name="card-tabs">Variant="TabsVariant.Card" for separated tab sections</ai-pattern>
<ai-pattern name="closable-tabs">IsClosable="true" on RTabItem for document-style tabs</ai-pattern>
<ai-pattern name="badge-tabs">BadgeCount on RTabItem for notification indicators</ai-pattern>
**@
@using RR.Blazor.Enums
@using RR.Blazor.Attributes
@implements IDisposable
@inject IJSRuntime JSRuntime

@attribute [Component("RTabs", Category = "Navigation", Complexity = ComponentComplexity.Complex)]
@attribute [AIOptimized(Prompt = "Create professional tabs for content organization", 
                       CommonUse = "dashboards, forms, data views, settings panels", 
                       AvoidUsage = "Don't use for navigation breadcrumbs - use RBreadcrumbs instead")]

<CascadingValue Value="this">
    <div @ref="tabsElement" class="tabs @Class">
        <!-- Tab Navigation -->
    <nav class="tabs__nav tabs__nav--@Variant.ToString().ToLower()" role="tablist">
        <!-- Animated Indicator -->
        @if (Variant != TabsVariant.Card)
        {
            <div class="tabs__indicator" style="@GetIndicatorStyle()"></div>
        }
        
        <!-- Tab Headers -->
        @foreach (var tab in tabs)
        {
            <button type="button"
                    class="tabs__tab @GetTabClasses(tab)"
                    role="tab"
                    aria-selected="@(tab.Id == ActiveTabId)"
                    aria-controls="panel-@tab.Id"
                    tabindex="@(tab.Id == ActiveTabId ? 0 : -1)"
                    disabled="@tab.IsDisabled"
                    @onclick="() => SelectTab(tab.Id)"
                    @onkeydown="@(e => HandleKeyDown(e, tab.Id))">
                
                @if (!string.IsNullOrEmpty(tab.Icon) && tab.IconPosition == IconPosition.Start)
                {
                    <i class="material-symbols-rounded tabs__tab__icon tabs__tab__icon--start @GetTabIconSize()">@tab.Icon</i>
                }
                
                @if (!string.IsNullOrEmpty(tab.Text))
                {
                    <span>@tab.Text</span>
                }
                
                @if (tab.BadgeCount > 0)
                {
                    <span class="tabs__tab__badge @GetBadgeVariant(tab.BadgeVariant)">
                        @(tab.BadgeCount > 99 ? "99+" : tab.BadgeCount.ToString())
                    </span>
                }
                
                @if (!string.IsNullOrEmpty(tab.Icon) && tab.IconPosition == IconPosition.End)
                {
                    <i class="material-symbols-rounded tabs__tab__icon tabs__tab__icon--end @GetTabIconSize()">@tab.Icon</i>
                }
                
                @if (tab.IsClosable)
                {
                    <button type="button" 
                            class="tabs__tab__close"
                            @onclick="() => CloseTab(tab.Id)"
                            @onclick:stopPropagation="true">
                        <i class="material-symbols-rounded text-xs">close</i>
                    </button>
                }
            </button>
        }
        
        <!-- Add Tab Button -->
        @if (ShowAddButton)
        {
            <button type="button" 
                    class="tabs__tab tabs__tab--add-button"
                    @onclick="HandleAddTab">
                <i class="material-symbols-rounded text-sm">add</i>
            </button>
        }
    </nav>
    
    <!-- Tab Content -->
    <div class="tabs__content @(NoPadding ? "tabs__content--no-padding" : "")">
        @foreach (var tab in tabs)
        {
            <div id="panel-@tab.Id"
                 class="tabs__panel @(tab.Id == ActiveTabId ? "tabs__panel--active" : "") @(FadeOnly ? "tabs__panel--fade-only" : "")"
                 role="tabpanel"
                 aria-labelledby="tab-@tab.Id"
                 tabindex="0">
                @tab.Content
            </div>
        }
    </div>
    
    @ChildContent
    </div>
</CascadingValue>

@code {
    /// <summary>Tab variant style</summary>
    [Parameter, AIParameter("Visual style of tabs", "TabsVariant.Default, TabsVariant.Pills, TabsVariant.Card")] 
    public TabsVariant Variant { get; set; } = TabsVariant.Default;
    
    /// <summary>Size of tabs</summary>
    [Parameter, AIParameter("Size of tab items", "ButtonSize.Small, ButtonSize.Medium, ButtonSize.Large")] 
    public ButtonSize Size { get; set; } = ButtonSize.Medium;
    
    /// <summary>Active tab ID</summary>
    [Parameter, AIParameter("ID of currently active tab", "Use with @bind-ActiveTabId for two-way binding")] 
    public string ActiveTabId { get; set; }
    
    /// <summary>Callback when active tab changes</summary>
    [Parameter] public EventCallback<string> ActiveTabIdChanged { get; set; }
    
    /// <summary>Whether to show add tab button</summary>
    [Parameter, AIParameter("Show + button for adding new tabs", "true for dynamic tab creation")] 
    public bool ShowAddButton { get; set; }
    
    /// <summary>Whether tab content has no padding</summary>
    [Parameter, AIParameter("Remove padding from tab content area", "true for full-width content like tables")] 
    public bool NoPadding { get; set; }
    
    /// <summary>Use fade only animation (no slide)</summary>
    [Parameter] public bool FadeOnly { get; set; }
    
    /// <summary>Additional CSS classes</summary>
    [Parameter] public string Class { get; set; }
    
    /// <summary>Child content containing RTabItem components</summary>
    [Parameter] public RenderFragment ChildContent { get; set; }
    
    /// <summary>Called when tab selection changes</summary>
    [Parameter] public EventCallback<TabChangedEventArgs> OnTabChanged { get; set; }
    
    /// <summary>Called when add tab button is clicked</summary>
    [Parameter] public EventCallback OnAddTab { get; set; }
    
    /// <summary>Called when tab close button is clicked</summary>
    [Parameter] public EventCallback<TabClosedEventArgs> OnTabClosed { get; set; }
    
    private readonly List<RTabItemInfo> tabs = new();
    private ElementReference tabsElement;
    private ElementReference? activeTabElement;
    private double indicatorLeft = 0;
    private double indicatorWidth = 0;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Initialize tabs with scroll detection
                await JSRuntime.InvokeVoidAsync("RRBlazor.initializeTabs", tabsElement, new { });
                await UpdateIndicatorPosition();
            }
            catch (Exception ex)
            {
                // Fallback if JS fails
                Console.WriteLine($"RTabs initialization failed: {ex.Message}");
            }
        }
    }
    
    public void AddTab(RTabItemInfo tab)
    {
        tabs.Add(tab);
        
        // Set first tab as active if none selected
        if (string.IsNullOrEmpty(ActiveTabId) && tabs.Count == 1)
        {
            ActiveTabId = tab.Id;
        }
        
        StateHasChanged();
    }
    
    public void RemoveTab(string tabId)
    {
        var tab = tabs.FirstOrDefault(t => t.Id == tabId);
        if (tab != null)
        {
            tabs.Remove(tab);
            
            // Select another tab if removing active tab
            if (ActiveTabId == tabId && tabs.Any())
            {
                var index = tabs.FindIndex(t => t.Id == tabId);
                if (index > 0)
                {
                    ActiveTabId = tabs[index - 1].Id;
                }
                else if (tabs.Any())
                {
                    ActiveTabId = tabs[0].Id;
                }
            }
            
            StateHasChanged();
        }
    }
    
    private async Task SelectTab(string tabId)
    {
        if (tabId == ActiveTabId) return;
        
        var oldTabId = ActiveTabId;
        ActiveTabId = tabId;
        
        await ActiveTabIdChanged.InvokeAsync(ActiveTabId);
        await OnTabChanged.InvokeAsync(new TabChangedEventArgs
        {
            OldTabId = oldTabId,
            NewTabId = ActiveTabId
        });
        
        await UpdateIndicatorPosition();
        StateHasChanged();
    }
    
    private async Task CloseTab(string tabId)
    {
        await OnTabClosed.InvokeAsync(new TabClosedEventArgs { TabId = tabId });
        RemoveTab(tabId);
    }
    
    private async Task HandleAddTab()
    {
        await OnAddTab.InvokeAsync();
    }
    
    private async Task HandleKeyDown(KeyboardEventArgs e, string tabId)
    {
        switch (e.Key)
        {
            case "ArrowLeft":
                await NavigateTab(-1);
                break;
            case "ArrowRight":
                await NavigateTab(1);
                break;
            case "Home":
                if (tabs.Any())
                {
                    await SelectTab(tabs.First().Id);
                }
                break;
            case "End":
                if (tabs.Any())
                {
                    await SelectTab(tabs.Last().Id);
                }
                break;
            case "Delete":
                if (tabs.FirstOrDefault(t => t.Id == tabId)?.IsClosable == true)
                {
                    await CloseTab(tabId);
                }
                break;
        }
    }
    
    private async Task NavigateTab(int direction)
    {
        var currentIndex = tabs.FindIndex(t => t.Id == ActiveTabId);
        if (currentIndex >= 0)
        {
            var newIndex = currentIndex + direction;
            if (newIndex >= 0 && newIndex < tabs.Count)
            {
                await SelectTab(tabs[newIndex].Id);
            }
        }
    }
    
    private async Task UpdateIndicatorPosition()
    {
        if (string.IsNullOrEmpty(ActiveTabId) || Variant == TabsVariant.Card)
            return;
            
        try
        {
            var activeTab = tabs.FirstOrDefault(t => t.Id == ActiveTabId);
            if (activeTab != null)
            {
                var result = await JSRuntime.InvokeAsync<TabIndicatorPosition>("RRBlazor.getTabIndicatorPosition", $"tab-{ActiveTabId}");
                indicatorLeft = result.Left;
                indicatorWidth = result.Width;
                StateHasChanged();
            }
        }
        catch
        {
            // Fallback if JS fails
        }
    }
    
    private string GetTabClasses(RTabItemInfo tab)
    {
        var classes = new List<string>();
        
        // Size classes
        classes.Add(Size switch
        {
            ButtonSize.Small => "tabs__tab--small",
            ButtonSize.Large => "tabs__tab--large",
            _ => ""
        });
        
        // State classes
        if (tab.Id == ActiveTabId)
        {
            classes.Add("tabs__tab--active");
        }
        
        if (tab.IsDisabled)
        {
            classes.Add("tabs__tab--disabled");
        }
        
        return string.Join(" ", classes.Where(c => !string.IsNullOrEmpty(c)));
    }
    
    private string GetTabIconSize() => Size switch
    {
        ButtonSize.Small => "text-sm",
        ButtonSize.Large => "text-lg",
        _ => "text-base"
    };
    
    private string GetBadgeVariant(string variant) => variant switch
    {
        "danger" => "tabs__tab__badge--danger",
        "warning" => "tabs__tab__badge--warning", 
        "success" => "tabs__tab__badge--success",
        _ => ""
    };
    
    private string GetIndicatorStyle()
    {
        return $"left: {indicatorLeft}px; width: {indicatorWidth}px;";
    }
    
    public void Dispose()
    {
        // Cleanup if needed
    }
    
    public class RTabItemInfo
    {
        public string Id { get; set; } = Guid.NewGuid().ToString();
        public string Text { get; set; }
        public string Icon { get; set; }
        public IconPosition IconPosition { get; set; } = IconPosition.Start;
        public bool IsDisabled { get; set; }
        public bool IsClosable { get; set; }
        public int BadgeCount { get; set; }
        public string BadgeVariant { get; set; }
        public RenderFragment Content { get; set; }
    }
    
    public class TabChangedEventArgs
    {
        public string OldTabId { get; set; }
        public string NewTabId { get; set; }
    }
    
    public class TabClosedEventArgs
    {
        public string TabId { get; set; } = "";
    }
    
    private class TabIndicatorPosition
    {
        public double Left { get; set; }
        public double Width { get; set; }
    }
}

