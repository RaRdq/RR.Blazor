@** 
<summary>
Tab container for organizing content with smooth animations.
</summary>
<category>Navigation</category>
<complexity>Complex</complexity>
<ai-prompt>Create tabs for content organization</ai-prompt>
<ai-common-use>dashboards, forms, data views, settings panels</ai-common-use>
<ai-avoid>Don't use for navigation breadcrumbs - use RBreadcrumbs instead</ai-avoid>
**@
@using RR.Blazor.Enums
@using RR.Blazor.Attributes
@using RR.Blazor.Components
@using RR.Blazor.Components.Base
@using RR.Blazor.Components.Display
@using RR.Blazor.Utilities
@inherits RSizedComponentBase<SizeType>
@implements IDisposable

@attribute [Component("RTabs", Category = "Navigation", Complexity = ComponentComplexity.Complex)]
@attribute [AIOptimized(Prompt = "Create professional tabs for content organization", 
                       CommonUse = "dashboards, forms, data views, settings panels", 
                       AvoidUsage = "Don't use for navigation breadcrumbs - use RBreadcrumbs instead")]

<CascadingValue Value="@this">
    @ChildContent
    
    <div @ref="tabsElement" class="tabs @GetTabsClasses()" @attributes="GetSafeAttributes()">
        @if (tabs.Count == 0)
        {
            <REmptyState Icon="tab" 
                         Text="@($"No tabs available ({tabs.Count} tabs registered)")" 
                         Description="@($"This tab container has no content to display. Debug: {(ChildContent != null ? "Has ChildContent" : "No ChildContent")}")" />
        }
        else
        {
        <!-- Tab Navigation with Scroll Arrows -->
        <nav class="@GetNavClasses()" role="tablist" aria-label="@AriaLabel">
        <!-- Left Scroll Arrow -->
        <button type="button" 
                class="tabs-nav-arrow tabs-nav-arrow-left @GetScrollArrowClasses(canScrollLeft)"
                @onclick="ScrollLeft"
                aria-label="Scroll tabs left">
            <i class="icon">chevron_left</i>
        </button>
        
        <!-- Scrollable Tab Container -->
        <div class="tabs-nav-container" @ref="navContainer">
            <div class="tabs-nav-wrapper" @ref="navWrapper">
                <!-- Animated Indicator -->
                @if (Variant != TabsVariant.Card)
                {
                    <div class="tabs-indicator" style="@GetIndicatorStyle()"></div>
                }
                
                <!-- Tab Headers -->
                @foreach (var tab in tabs)
                {
                    <button type="button"
                            id="tab-@tab.Id"
                            class="@GetTabClasses(tab)"
                            role="tab"
                            aria-selected="@(tab.Id == ActiveTabId)"
                            aria-controls="panel-@tab.Id"
                            aria-label="@(!string.IsNullOrEmpty(tab.AriaLabel) ? tab.AriaLabel : tab.Text)"
                            tabindex="@(tab.Id == ActiveTabId ? 0 : -1)"
                            disabled="@tab.IsDisabled"
                            @onclick="() => SelectTab(tab.Id)"
                            @onkeydown="@(e => HandleKeyDown(e, tab.Id))">
                        
                        @if (!string.IsNullOrEmpty(tab.Icon) && tab.IconPosition == IconPosition.Start)
                        {
                            <i class="icon @GetTabIconSize() mr-2">@tab.Icon</i>
                        }
                        
                        @if (!string.IsNullOrEmpty(tab.Text))
                        {
                            <span>@tab.Text</span>
                        }
                        
                        @if (tab.BadgeCount > 0)
                        {
                            <span class="tabs-tab-badge ml-2 px-2 py-1 text-xs rounded-full @GetBadgeVariant(tab.BadgeVariant)">
                                @(tab.BadgeCount > 99 ? "99+" : tab.BadgeCount.ToString())
                            </span>
                        }
                        
                        @if (!string.IsNullOrEmpty(tab.Icon) && tab.IconPosition == IconPosition.End)
                        {
                            <i class="icon @GetTabIconSize() ml-2">@tab.Icon</i>
                        }
                        
                        @if (tab.Closable)
                        {
                            <button type="button" 
                                    class="ml-2 p-1 rounded hover-scale-sm active-scale-sm transition-transform"
                                    @onclick="() => CloseTab(tab.Id)"
                                    @onclick:stopPropagation="true">
                                <i class="icon text-xs">close</i>
                            </button>
                        }
                    </button>
                }
                
                <!-- Add Tab Button -->
                @if (ShowAddButton)
                {
                    <button type="button" 
                            class="touch-target px-3 py-2 rounded-md hover-lift-sm transition-all border border-dashed border-secondary"
                            @onclick="HandleAddTab">
                        <i class="icon text-sm">add</i>
                    </button>
                }
            </div>
        </div>
        
        <!-- Right Scroll Arrow -->
        <button type="button" 
                class="tabs-nav-arrow tabs-nav-arrow-right @GetScrollArrowClasses(canScrollRight)"
                @onclick="ScrollRight"
                aria-label="Scroll tabs right">
            <i class="icon">chevron_right</i>
        </button>
    </nav>
    
        <!-- Tab Content -->
        <div class="@GetContentClasses()">
            @foreach (var tab in tabs)
            {
                @if (KeepPanelsAlive || tab.Id == ActiveTabId)
                {
                    <div id="panel-@tab.Id"
                         class="tabs-panel @(tab.Id == ActiveTabId ? "tabs-panel-active" : "") @(FadeOnly ? "tabs-panel-fade-only" : "")"
                         role="tabpanel"
                         aria-labelledby="tab-@tab.Id"
                         tabindex="0">
                        @if (Loading && tab.Id == ActiveTabId)
                        {
                            <RSkeleton Loading="true" Type="SkeletonType.Card">
                                @tab.Content
                            </RSkeleton>
                        }
                        else
                        {
                            @tab.Content
                        }
                    </div>
                }
            }
        </div>
        }
    </div>
</CascadingValue>

@code {
    /// <summary>Tab variant style</summary>
    [Parameter, AIParameter("Visual style of tabs", "TabsVariant.Default, TabsVariant.Pills, TabsVariant.Card")] 
    public TabsVariant Variant { get; set; } = TabsVariant.Default;
    
    
    /// <summary>Active tab ID</summary>
    [Parameter, AIParameter("ID of currently active tab", "Use with @bind-ActiveTabId for two-way binding")] 
    public string ActiveTabId { get; set; }
    
    /// <summary>Callback when active tab changes</summary>
    [Parameter] public EventCallback<string> ActiveTabIdChanged { get; set; }
    
    /// <summary>Selected tab for two-way binding (alias for ActiveTabId)</summary>
    [Parameter, AIParameter("ID of currently selected tab", "Use with @bind-SelectedTab for two-way binding")] 
    public string SelectedTab 
    { 
        get => ActiveTabId; 
        set => ActiveTabId = value; 
    }
    
    /// <summary>Callback when selected tab changes</summary>
    [Parameter] public EventCallback<string> SelectedTabChanged { get; set; }
    
    /// <summary>Whether to show add tab button</summary>
    [Parameter, AIParameter("Show + button for adding new tabs", "true for dynamic tab creation")] 
    public bool ShowAddButton { get; set; }
    
    
    /// <summary>Whether tab content has no padding</summary>
    [Parameter, AIParameter("Remove padding from tab content area", "true for full-width content like tables")] 
    public bool NoPadding { get; set; }
    
    /// <summary>Use fade only animation (no slide)</summary>
    [Parameter] public bool FadeOnly { get; set; }
    
    
    /// <summary>Whether to keep all tab panels alive (renders all content, disables lazy loading)</summary>
    [Parameter, AIParameter("Keep all tab panels alive in DOM", "false for lazy loading (performance), true to keep all panels rendered")] 
    public bool KeepPanelsAlive { get; set; } = false;
    
    
    
    
    /// <summary>Called when tab selection changes</summary>
    [Parameter] public EventCallback<TabChangedEventArgs> OnTabChanged { get; set; }
    
    /// <summary>Called when add tab button is clicked</summary>
    [Parameter] public EventCallback OnAddTab { get; set; }
    
    /// <summary>Called when tab close button is clicked</summary>
    [Parameter] public EventCallback<TabClosedEventArgs> OnTabClosed { get; set; }
    
    
    private readonly List<RTabItemInfo> tabs = new();
    private ElementReference tabsElement;
    private ElementReference navContainer;
    private ElementReference navWrapper;
    private double indicatorLeft = 0;
    private double indicatorWidth = 0;
    private bool isScrollable = false;
    private bool canScrollLeft = false;
    private bool canScrollRight = false;
    private bool isUpdatingIndicator = false;
    private bool isUpdatingScrollState = false;
    private bool wasActiveTabIdSetExternally = false;
    
    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Track if ActiveTabId was set externally (from parameter)
        wasActiveTabIdSetExternally = !string.IsNullOrEmpty(ActiveTabId);
    }
    
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        var currentActiveTab = tabs.FirstOrDefault(t => t.Id == ActiveTabId);
        
        if (!string.IsNullOrEmpty(ActiveTabId) && currentActiveTab != null)
        {
            wasActiveTabIdSetExternally = true;
            StateHasChanged();
        }
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                await SafeInvokeAsync("initializeTabs", tabsElement, navContainer, navWrapper);
                
                if (tabs.Count > 0)
                {
                    await UpdateIndicatorPosition();
                    await Task.Yield();
                    await UpdateScrollState();
                }
            }
            catch
            {
                // Silently handle initialization errors
            }
        }
        else if (tabs.Count > 0 && !isUpdatingIndicator && !isUpdatingScrollState)
        {
            // Only update scroll state when not already updating to prevent render loops
            _ = InvokeAsync(async () =>
            {
                try
                {
                    await Task.Yield(); // Let Blazor render
                    if (!isUpdatingIndicator && !isUpdatingScrollState) // Double-check to prevent race conditions
                    {
                        await UpdateScrollState();
                    }
                }
                catch
                {
                    // Silently handle update errors
                }
            });
        }
    }
    
    public void AddTab(RTabItemInfo tab)
    {
        if (tab == null) return;
        
        var existingTab = tabs.FirstOrDefault(t => t.Id == tab.Id);
        if (existingTab != null)
        {
            existingTab.Text = tab.Text;
            existingTab.Icon = tab.Icon;
            existingTab.IconPosition = tab.IconPosition;
            existingTab.IsDisabled = tab.IsDisabled;
            existingTab.Closable = tab.Closable;
            existingTab.BadgeCount = tab.BadgeCount;
            existingTab.BadgeVariant = tab.BadgeVariant;
            existingTab.Content = tab.Content;
        }
        else
        {
            tabs.Add(tab);
        }
        
        if (string.IsNullOrEmpty(ActiveTabId) && tabs.Count == 1)
        {
            ActiveTabId = tabs[0].Id;
        }
        else if (!string.IsNullOrEmpty(ActiveTabId) && tab.Id == ActiveTabId)
        {
            wasActiveTabIdSetExternally = true;
        }
        
        StateHasChanged();
        
        // Debounce updates to prevent render loops
        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Yield(); // Let DOM update
                await InvokeAsync(async () => 
                {
                    await UpdateScrollState();
                    await UpdateIndicatorPosition();
                });
            }
            catch
            {
            }
        });
    }
    
    public List<RTabItemInfo> GetTabs()
    {
        return tabs;
    }
    
    public void RemoveTab(string tabId)
    {
        var tab = tabs.FirstOrDefault(t => t.Id == tabId);
        if (tab != null)
        {
            tabs.Remove(tab);
            

            if (ActiveTabId == tabId && tabs.Any())
            {
                var index = tabs.FindIndex(t => t.Id == tabId);
                if (index > 0)
                {
                    ActiveTabId = tabs[index - 1].Id;
                }
                else if (tabs.Any())
                {
                    ActiveTabId = tabs[0].Id;
                }
            }
            
            StateHasChanged();
        }
    }
    
    private async Task SelectTab(string tabId)
    {
        if (tabId == ActiveTabId) return;
        
        var oldTabId = ActiveTabId;
        
        // Update the ActiveTabId immediately
        ActiveTabId = tabId;
        wasActiveTabIdSetExternally = true; // Mark as set so it won't be overridden
        
        // Invoke the two-way binding callbacks IMMEDIATELY for proper data binding
        if (ActiveTabIdChanged.HasDelegate)
        {
            await ActiveTabIdChanged.InvokeAsync(ActiveTabId);
        }
        
        if (SelectedTabChanged.HasDelegate)
        {
            await SelectedTabChanged.InvokeAsync(ActiveTabId);
        }
        
        // Trigger state change after binding update
        StateHasChanged();
        
        // Invoke tab changed event
        if (OnTabChanged.HasDelegate)
        {
            await OnTabChanged.InvokeAsync(new TabChangedEventArgs
            {
                OldTabId = oldTabId,
                NewTabId = ActiveTabId
            });
        }
        
        // Update visual elements asynchronously to avoid blocking
        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Yield(); // Let DOM update
                await InvokeAsync(async () =>
                {
                    await ScrollToTab(tabId);
                    await UpdateIndicatorPosition();
                });
            }
            catch
            {
                // Silently handle visual update errors
            }
        });
    }
    
    private async Task CloseTab(string tabId)
    {
        await OnTabClosed.InvokeAsync(new TabClosedEventArgs { TabId = tabId });
        RemoveTab(tabId);
    }
    
    private async Task HandleAddTab()
    {
        await OnAddTab.InvokeAsync();
    }
    
    private async Task HandleKeyDown(KeyboardEventArgs e, string tabId)
    {
        switch (e.Key)
        {
            case "ArrowLeft":
                await NavigateTab(-1);
                break;
            case "ArrowRight":
                await NavigateTab(1);
                break;
            case "Home":
                if (tabs.Any())
                {
                    await SelectTab(tabs.First().Id);
                }
                break;
            case "End":
                if (tabs.Any())
                {
                    await SelectTab(tabs.Last().Id);
                }
                break;
            case "Delete":
                if (tabs.FirstOrDefault(t => t.Id == tabId)?.Closable == true)
                {
                    await CloseTab(tabId);
                }
                break;
        }
    }
    
    private async Task NavigateTab(int direction)
    {
        var currentIndex = tabs.FindIndex(t => t.Id == ActiveTabId);
        if (currentIndex >= 0)
        {
            var newIndex = currentIndex + direction;
            if (newIndex >= 0 && newIndex < tabs.Count)
            {
                await SelectTab(tabs[newIndex].Id);
            }
        }
    }
    
    private async Task UpdateIndicatorPosition()
    {
        if (string.IsNullOrEmpty(ActiveTabId) || Variant == TabsVariant.Card || isUpdatingIndicator)
            return;
            
        try
        {
            isUpdatingIndicator = true;
            
            var activeTab = tabs.FirstOrDefault(t => t.Id == ActiveTabId);
            if (activeTab != null)
            {
                var result = await SafeInvokeAsync<TabIndicatorPosition>("getTabIndicatorPosition", $"tab-{ActiveTabId}", navWrapper);
                
                // Only update if values have actually changed to prevent unnecessary re-renders
                if (Math.Abs(indicatorLeft - result.Left) > 0.5 || Math.Abs(indicatorWidth - result.Width) > 0.5)
                {
                    indicatorLeft = result.Left;
                    indicatorWidth = result.Width;
                    StateHasChanged();
                }
            }
        }
        catch
        {
        }
        finally
        {
            isUpdatingIndicator = false;
        }
    }
    
    private async Task UpdateScrollState()
    {
        if (isUpdatingScrollState) return; // Prevent concurrent updates
        
        try
        {
            isUpdatingScrollState = true;

            if (tabs.Count <= 1)
            {
                if (isScrollable || canScrollLeft || canScrollRight)
                {
                    isScrollable = false;
                    canScrollLeft = false;
                    canScrollRight = false;
                    StateHasChanged();
                }
                return;
            }
            
            var scrollInfo = await SafeInvokeAsync<ScrollInfo>("getTabScrollInfo", navWrapper);
            

            if (isScrollable != scrollInfo.IsScrollable || 
                canScrollLeft != scrollInfo.CanScrollLeft || 
                canScrollRight != scrollInfo.CanScrollRight)
            {
                isScrollable = scrollInfo.IsScrollable;
                canScrollLeft = scrollInfo.CanScrollLeft;
                canScrollRight = scrollInfo.CanScrollRight;
                StateHasChanged();
            }
        }
        catch
        {

            if (isScrollable || canScrollLeft || canScrollRight)
            {
                isScrollable = false;
                canScrollLeft = false;
                canScrollRight = false;
                StateHasChanged();
            }
        }
        finally
        {
            isUpdatingScrollState = false;
        }
    }
    
    private async Task ScrollLeft()
    {
        try
        {
            await SafeInvokeAsync("scrollTabsLeft", navWrapper);
            await UpdateScrollState();
        }
        catch
        {
        }
    }
    
    private async Task ScrollRight()
    {
        try
        {
            await SafeInvokeAsync("scrollTabsRight", navWrapper);
            await UpdateScrollState();
        }
        catch
        {
        }
    }
    
    private async Task ScrollToTab(string tabId)
    {
        try
        {
            await SafeInvokeAsync("scrollToTab", navWrapper, $"tab-{tabId}");
            await UpdateScrollState();
        }
        catch
        {
        }
    }
    
    private string GetTabClasses(RTabItemInfo tab)
    {
        var classes = new List<string>();
        
        classes.Add("tabs-tab");
        
        classes.Add(GetTabSizeUtilities());
        
        if (tab.Id == ActiveTabId)
        {
            classes.Add("tabs-tab-active tab-active");
        }
        // Hover and inactive states are handled by CSS
        
        if (tab.IsDisabled)
        {
            classes.Add("state-disabled");
        }
        
        return string.Join(" ", classes.Where(c => !string.IsNullOrEmpty(c)));
    }

    private string GetTabSizeUtilities()
    {
        var buttonClasses = SizeHelper.GetButtonSize(Size, Density);
        var textClass = SizeHelper.GetTextSize(Size, Density);
        var gap = DensityHelper.GetGap(Density);
        
        var hPadding = DensityHelper.GetHorizontalPadding(Density, "4");
        var vPadding = DensityHelper.GetVerticalPadding(Density, "3");
        var paddingClass = $"px-{hPadding} py-{vPadding}";
        
        return $"{paddingClass} {textClass} gap-{gap}";
    }
    
    private string GetTabIconSize()
    {
        return SizeHelper.GetIconSize(Size, Density);
    }
    
    private string GetBadgeVariant(string variant) => variant switch
    {
        "danger" => "tabs-tab-badge-danger",
        "warning" => "tabs-tab-badge-warning", 
        "success" => "tabs-tab-badge-success",
        _ => ""
    };
    
    private string GetIndicatorStyle()
    {
        return $"--indicator-left: {indicatorLeft.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)}px; --indicator-width: {indicatorWidth.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)}px;";
    }
    
    private string GetTabsClasses()
    {
        var classes = new List<string> { "tabs d-flex flex-col w-full" };
        
        // Add variant-specific classes
        var variantClass = Variant switch
        {
            TabsVariant.Pills => "tabs-pills",
            TabsVariant.Card => "tabs-card",
            TabsVariant.Underline => "tabs-underline", 
            TabsVariant.Elevated => "tabs-elevated",
            TabsVariant.Segment => "tabs-segment",
            _ => "tabs-default"
        };
        classes.Add(variantClass);
        
        if (!string.IsNullOrEmpty(Class))
            classes.Add(Class);
            
        return string.Join(" ", classes);
    }
    
    private string GetNavClasses()
    {
        var classes = new List<string> { "tabs-nav" };
        
        // The variant-specific styling is handled by CSS, just add the base class
        return string.Join(" ", classes);
    }
    
    private string GetContentClasses()
    {
        var classes = new List<string> { "tabs-content" };
        
        if (!NoPadding)
        {
            // Padding is handled by CSS variants
        }
        else
        {
            classes.Add("tabs-content-no-padding");
        }
        
        // Variant-specific styling is handled by CSS
        return string.Join(" ", classes);
    }
    
    private string GetScrollArrowClasses(bool canScroll)
    {
        var classes = new List<string>();
        
        if (canScroll && isScrollable)
        {
            classes.Add("tabs-nav-arrow-visible");
        }
        
        return string.Join(" ", classes);
    }
    
    protected override string GetSizeClasses()
    {
        return Size switch
        {
            SizeType.ExtraSmall => "tabs-xs",
            SizeType.Small => "tabs-sm",
            SizeType.Medium => "tabs-md",
            SizeType.Large => "tabs-lg",
            SizeType.ExtraLarge => "tabs-xl",
            _ => "tabs-md"
        };
    }
    
    protected override SizeType GetDefaultSize() => SizeType.Medium;
    
    public void Dispose()
    {

    }
    
    public class RTabItemInfo
    {
        public string Id { get; set; } = $"tab-{Guid.NewGuid():N}";
        public string Text { get; set; }
        public string Icon { get; set; }
        public IconPosition IconPosition { get; set; } = IconPosition.Start;
        public bool IsDisabled { get; set; }
        public bool Closable { get; set; }
        public int BadgeCount { get; set; }
        public string BadgeVariant { get; set; }
        public string AriaLabel { get; set; }
        public RenderFragment Content { get; set; }
    }
    
    public class TabChangedEventArgs
    {
        public string OldTabId { get; set; }
        public string NewTabId { get; set; }
    }
    
    public class TabClosedEventArgs
    {
        public string TabId { get; set; } = "";
    }
    
    private class TabIndicatorPosition
    {
        public double Left { get; set; }
        public double Width { get; set; }
    }
    
    private class ScrollInfo
    {
        public bool IsScrollable { get; set; }
        public bool CanScrollLeft { get; set; }
        public bool CanScrollRight { get; set; }
    }
}


