@using RR.Blazor.Models
@using RR.Blazor.Services
@using RR.Blazor.Enums
@using System.Reflection
@using Microsoft.AspNetCore.Components
@implements IDisposable
@inject IModalService ModalService
@inject IJSRuntime JSRuntime
@inject IJavaScriptInteropService JSInterop

@* RModalProvider - Portal-based modal container for body-level rendering *@
<div id="modal-portal-container" style="display: none;">
    @foreach (var modal in _activeModals)
    {
        @if (modal.Options.ComponentType != null && ComponentHasInternalModal(modal.Options.ComponentType))
        {
            @* Case 3: Component with RModal wrapper - render directly without double-wrapping *@
            <div @key="modal.Id" data-modal-id="@modal.Id" data-portal="true">
                <DynamicComponent Type="@modal.Options.ComponentType" Parameters="@GetComponentParameters(modal)" />
            </div>
        }
        else
        {
            @* Case 4: Component without RModal - auto-wrap in RModal *@
            <RModal @key="modal.Id"
                    @ref="modalRefs[modal.Id]"
                    Visible="@modal.Visible"
                    Title="@modal.Options.Title"
                    Subtitle="@modal.Options.Subtitle"
                    Icon="@modal.Options.Icon"
                    Size="@modal.Options.Size"
                    Variant="@modal.Options.Variant"
                    CloseOnBackdrop="@modal.Options.CloseOnBackdrop"
                    CloseOnEscape="@modal.Options.CloseOnEscape"
                    ShowCloseButton="@modal.Options.ShowCloseButton"
                    ShowHeader="@modal.Options.ShowHeader"
                    ShowFooter="@modal.Options.ShowFooter"
                    Class="@modal.Options.Class"
                    data-modal-id="@modal.Id"
                    data-portal="true"
                    OnClose="@(() => HandleModalClose(modal))"
                    OnCancel="@(() => HandleModalCancel(modal))"
                    OnPrimaryAction="@(() => HandlePrimaryAction(modal))"
                    FooterContent="@(modal.Options.Buttons.Any() ? CreateModalFooter(modal) : null)">
                
                @if (modal.Options.ComponentType != null)
                {
                    <DynamicComponent Type="@modal.Options.ComponentType" Parameters="@GetComponentParameters(modal)" />
                }
                else if (modal.Options.Data != null)
                {
                    @* Display simple content if no component specified *@
                    <div class="modal-simple-content">
                        @if (modal.Options.Data is string message)
                        {
                            <p>@message</p>
                        }
                        else
                        {
                            <pre>@System.Text.Json.JsonSerializer.Serialize(modal.Options.Data)</pre>
                        }
                    </div>
                }
            </RModal>
        }
    }
</div>

@code {
    private readonly List<ModalInstance> _activeModals = new();
    private readonly Dictionary<string, RModal> modalRefs = new();

    protected override async Task OnInitializedAsync()
    {
        ModalService.OnModalOpened += OnModalOpened;
        ModalService.OnModalClosed += OnModalClosed;
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Ensure portal container exists at body level
            await JSInterop.TryInvokeVoidAsync("RRBlazor.Portal.ensureContainer");
        }
    }

    private void OnModalOpened(ModalInstance modal)
    {
        InvokeAsync(async () =>
        {
            _activeModals.Add(modal);
            
            modal.Visible = true;
            StateHasChanged();
            
            await Task.Yield();
            
            await CreateModal(modal);
        });
    }

    private void OnModalClosed(ModalInstance modal)
    {
        InvokeAsync(async () =>
        {
            // Let modal.js handle cleanup
            await DestroyModal(modal);
            
            _activeModals.Remove(modal);
            modalRefs.Remove(modal.Id);
            
            StateHasChanged();
        });
    }

    private Dictionary<string, object> GetComponentParameters(ModalInstance modal)
    {
        var parameters = new Dictionary<string, object>();
        
        foreach (var param in modal.Options.Parameters)
        {
            parameters[param.Key] = param.Value;
        }
        
        if (modal.Options.Data != null)
        {
            parameters["Data"] = modal.Options.Data;
        }

        // Only add OnDataChanged if component supports it
        if (ComponentSupportsParameter(modal.Options.ComponentType, "OnDataChanged"))
        {
            parameters["OnDataChanged"] = EventCallback.Factory.Create<object>(this, data =>
            {
                modal.Result = data;
            });
        }

        return parameters;
    }

    private bool ComponentSupportsParameter(Type componentType, string parameterName)
    {
        if (componentType == null) return false;
        
        return componentType.GetProperties()
            .Any(p => p.Name == parameterName && 
                     p.GetCustomAttributes(typeof(ParameterAttribute), false).Any());
    }
    
    /// <summary>
    /// SOW COMPLIANT: Detection based on ModalContext parameter ONLY
    /// If component has ModalContext parameter, it has internal RModal wrapper
    /// If no ModalContext, it needs RModal wrapper from provider
    /// </summary>
    private bool ComponentHasInternalModal(Type componentType)
    {
        if (componentType == null) return false;
        
        // SOW Requirement: Detection via ModalContext ONLY
        return componentType.GetProperties()
            .Where(p => p.GetCustomAttributes(typeof(ParameterAttribute), false).Any())
            .Any(p => p.PropertyType == typeof(ModalContext));
    }

    private RenderFragment CreateModalFooter(ModalInstance modal)
    {
        return builder =>
        {
            builder.OpenElement(0, "div");
            builder.AddAttribute(1, "class", "modal-footer-buttons");

            var index = 2;
            foreach (var button in modal.Options.Buttons)
            {
                builder.OpenComponent(index++, typeof(RButton));
                builder.AddAttribute(index++, nameof(RButton.Text), button.Text);
                builder.AddAttribute(index++, nameof(RButton.Variant), button.Variant);
                builder.AddAttribute(index++, nameof(RButton.Icon), button.Icon);
                builder.AddAttribute(index++, nameof(RButton.IconPosition), IconPosition.Start);
                builder.AddAttribute(index++, nameof(RButton.Class), button.Class);
                builder.AddAttribute(index++, nameof(RButton.Disabled), button.IsDisabled);
                builder.AddAttribute(index++, nameof(RButton.Loading), button.IsLoading);
                builder.AddAttribute(index++, nameof(RButton.OnClick), EventCallback.Factory.Create<MouseEventArgs>(this, async (MouseEventArgs e) =>
                {
                    await HandleButtonClick(modal, button);
                }));
                builder.CloseComponent();
            }

            builder.CloseElement();
        };
    }

    private async Task HandleModalClose(ModalInstance modal) => await CloseModal(modal, Enums.ModalResult.Cancel);

    private async Task HandleModalCancel(ModalInstance modal) => await CloseModal(modal, Enums.ModalResult.Cancel);

    private async Task HandlePrimaryAction(ModalInstance modal)
    {
        var primaryButton = modal.Options.Buttons.FirstOrDefault(b => b.Variant == VariantType.Primary);
        if (primaryButton?.OnClick != null)
        {
            var canClose = await primaryButton.OnClick(modal.Result ?? modal.Options.Data);
            if (canClose)
            {
                await CloseModal(modal, primaryButton.Result);
            }
        }
        else
        {
            await CloseModal(modal, Enums.ModalResult.Ok);
        }
    }

    private async Task HandleButtonClick(ModalInstance modal, ModalButton button)
    {
        if (button.OnClick != null)
        {
            var canClose = await button.OnClick(modal.Result ?? modal.Options.Data);
            if (canClose)
            {
                await CloseModal(modal, button.Result);
            }
        }
        else
        {
            await CloseModal(modal, button.Result);
        }
    }

    private async Task CloseModal(ModalInstance modal, Enums.ModalResult result)
    {
        modal.Visible = false;
        
        await ModalService.CloseAsync(modal.Id, result);
    }

    public void Dispose()
    {
        ModalService.OnModalOpened -= OnModalOpened;
        ModalService.OnModalClosed -= OnModalClosed;
        
        // Let modal.js handle cleanup through RR-Blazor proxy
        try
        {
            _ = JSInterop.TryInvokeVoidAsync("RRBlazor.Modal.forceUnlock");
        }
        catch
        {
            // Ignore cleanup errors on dispose
        }
    }
    
    private async Task CreateModal(ModalInstance modal)
    {
        try
        {
            // Single JS call - all DOM management delegated to JavaScript
            var modalConfig = new
            {
                id = modal.Id,
                selector = $"[data-modal-id='{modal.Id}']",
                useBackdrop = modal.Options.UseBackdrop,
                closeOnEscape = modal.Options.CloseOnEscape,
                closeOnBackdropClick = modal.Options.CloseOnBackdrop,
                trapFocus = true,
                animationSpeed = modal.Options.AnimationSpeed.ToString().ToLower(),
                portalConfig = new
                {
                    targetSelector = "body",
                    portalId = $"modal-portal-{modal.Id}",
                    portalClass = "modal-portal"
                },
                retryConfig = new
                {
                    maxRetries = 10,
                    retryDelay = 50
                }
            };
            
            // JavaScript handles all DOM operations internally
            await JSInterop.TryInvokeVoidAsync("RRBlazor.Modal.createAndShow", modal.Id, "RModal", null, modalConfig);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Modal creation failed for {modal.Id}: {ex.Message}");
        }
    }
    
    private async Task DestroyModal(ModalInstance modal)
    {
        try
        {
            // Single call - JavaScript handles both modal and portal cleanup internally
            await JSInterop.TryInvokeVoidAsync("RRBlazor.Modal.destroy", modal.Id);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Modal destruction failed for {modal.Id}: {ex.Message}");
        }
    }
}