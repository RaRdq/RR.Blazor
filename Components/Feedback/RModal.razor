@using RR.Blazor.Enums
@using RR.Blazor.Services
@using RR.Blazor.Utilities
@using RR.Blazor.Components.Base
@using Microsoft.JSInterop
@inherits RVariantComponentBase<ModalSize, ModalVariant>
@implements IAsyncDisposable
@inject ModalStackService ModalStack
@* Modal dialog with backdrop, animations, and form integration *@

@* Auto-portaled modal with backdrop and positioning *@
@if (Visible)
{
    <div class="modal-content @GetSizeClass() @GetVisibilityClass() @GetAnimationClass() @GetBaseClasses()" 
         role="dialog" 
         aria-modal="true" 
         aria-labelledby="@ModalTitleId" 
         aria-describedby="@(!string.IsNullOrEmpty(Subtitle) ? ModalDescriptionId : null)"
         @ref="modalElement"
         @onclick:stopPropagation="true"
         tabindex="-1"
         style="@GetAnimationStyles()"
         @onkeydown="OnKeyDownHandler">
                     
                @if (ShowHeader)
                {
                    <div class="modal-header @GetModalHeaderClasses()">
                        <div class="d-flex items-center @GetModalHeaderClasses()">
                            @if (!string.IsNullOrEmpty(Icon))
                            {
                                <i class="material-symbols-rounded text-primary @GetIconSizeClass()" aria-hidden="true">@Icon</i>
                            }
                            <div class="d-flex flex-col">
                                <h3 id="@ModalTitleId" class="modal-title ma-0 @GetTitleClasses()">@Text</h3>
                                @if (!string.IsNullOrEmpty(Subtitle))
                                {
                                    <p id="@ModalDescriptionId" class="modal-subtitle ma-0 text-sm text-muted">@Subtitle</p>
                                }
                            </div>
                        </div>
                        <div class="header-actions d-flex items-center gap-2">
                            @HeaderContent
                            @if (ShowCloseButton)
                            {
                                <button type="button" 
                                        class="modal-close" 
                                        @onclick="HandleClose"
                                        @onclick:preventDefault="true"
                                        @onclick:stopPropagation="true"
                                        disabled="@Processing"
                                        aria-label="Close dialog">
                                    <i class="material-symbols-rounded icon-no-pointer" aria-hidden="true">close</i>
                                </button>
                            }
                        </div>
                    </div>
                }
                
                <div class="modal-body @GetModalBodyClasses()">
                    @if (Processing && ShowProcessingOverlay)
                    {
                        <div class="overlay-full overlay-light d-flex items-center justify-center">
                            <div class="d-flex flex-col items-center @GetProcessingOverlayClasses() bg-surface-elevated rounded-lg shadow-lg">
                                <div class="spinner-lg"></div>
                                <p class="text-base text-muted ma-0">@ProcessingMessage</p>
                            </div>
                        </div>
                    }
                    @ChildContent
                </div>
                
                @if (ShowFooter)
                {
                    <div class="modal-footer @GetModalFooterClasses()">
                        @if (FooterContent != null)
                        {
                            @FooterContent
                        }
                        else
                        {
                            <RActionGroup Direction="ActionGroupDirection.Horizontal" 
                                          Alignment="ActionGroupAlignment.End" 
                                          Spacing="ActionGroupSpacing.Medium"
                                          Density="@Density">
                                @if (ShowCancelButton)
                                {
                                    <RButton Variant="ButtonVariant.Ghost" 
                                            Size="@ButtonSize" 
                                            Icon="@CancelIcon" IconPosition="IconPosition.Start" 
                                            Class="@CancelButtonClass" 
                                            OnClick="@HandleCancel" 
                                            Disabled="@Processing">
                                        @CancelText
                                    </RButton>
                                }
                                @if (ShowPrimaryButton)
                                {
                                    <RButton Variant="ButtonVariant.Primary" 
                                            Size="@ButtonSize" 
                                            Icon="@(Processing && ShowPrimaryButtonSpinner ? null : PrimaryIcon)" IconPosition="IconPosition.Start" 
                                            Class="@PrimaryButtonClass" 
                                            OnClick="@HandlePrimaryAction" 
                                            Disabled="@(Processing || PrimaryButtonDisabled)"
                                            Loading="@(Processing && ShowPrimaryButtonSpinner)">
                                        @(Processing && !string.IsNullOrEmpty(ProcessingButtonText) ? ProcessingButtonText : PrimaryText)
                                    </RButton>
                                }
                            </RActionGroup>
                            @if (ShowUnsavedIndicator && HasUnsavedChanges)
                            {
                                <div class="d-flex items-center gap-2 pa-3 bg-info-light text-info rounded-lg">
                                    <i class="material-symbols-rounded">info</i>
                                    <span class="text-sm">You have unsaved changes</span>
                                </div>
                            }
                        }
                    </div>
                }
    </div> @* Close modal-content *@
}

@code {
    [Parameter] public bool Visible { get; set; }
    [Parameter] public EventCallback<bool> VisibleChanged { get; set; }
    
    /// <summary>
    /// Whether this modal should create a backdrop. When false, modal is rendered without backdrop (useful in RModalProvider).
    /// </summary>
    [Parameter] public bool UseBackdrop { get; set; } = true;
    

    private static int portalCounter = 0;
    private readonly string portalId = $"modal-auto-{System.Threading.Interlocked.Increment(ref portalCounter)}";
    private string? actualPortalId = null;
    private bool isPortalCreated = false;
    private bool previousVisible = false;
    private int modalZIndex = 1000;
    private bool focusTrapActive = false;
    
    // State machine for modal lifecycle
    private enum ModalState
    {
        Closed,
        Opening,
        Open,
        Closing
    }
    
    private ModalState currentState = ModalState.Closed;
    private readonly SemaphoreSlim stateLock = new SemaphoreSlim(1, 1);
    
    /// <summary>
    /// Animation style for modal appearance
    /// </summary>
    [Parameter] public ModalAnimation Animation { get; set; } = ModalAnimation.Scale;
    
    /// <summary>
    /// Speed/duration of the modal animation (controls both modal and backdrop)
    /// </summary>
    [Parameter] public AnimationSpeed AnimationSpeed { get; set; } = AnimationSpeed.Normal;
    
    [Parameter] public bool ShowHeader { get; set; } = true;
    
    
    [Parameter] public RenderFragment HeaderContent { get; set; }
    [Parameter] public bool ShowCloseButton { get; set; } = true;
    

    [Parameter] public bool ShowFooter { get; set; } = true;
    [Parameter] public RenderFragment FooterContent { get; set; }
    [Parameter] public bool ShowCancelButton { get; set; } = true;
    [Parameter] public string CancelText { get; set; } = "Cancel";
    [Parameter] public string CancelIcon { get; set; }
    [Parameter] public string CancelButtonClass { get; set; }
    [Parameter] public bool ShowPrimaryButton { get; set; } = true;
    [Parameter] public string PrimaryText { get; set; } = "Save";
    [Parameter] public string PrimaryIcon { get; set; }
    [Parameter] public string PrimaryButtonClass { get; set; }
    [Parameter] public bool PrimaryButtonDisabled { get; set; }
    [Parameter] public ButtonSize ButtonSize { get; set; } = ButtonSize.Medium;

    [Parameter] public bool Processing { get; set; }
    [Parameter] public string ProcessingMessage { get; set; } = "Processing...";
    [Parameter] public string ProcessingButtonText { get; set; }
    [Parameter] public bool ShowProcessingOverlay { get; set; } = true;
    [Parameter] public bool ShowPrimaryButtonSpinner { get; set; } = true;

    [Parameter] public bool ShowUnsavedIndicator { get; set; }
    [Parameter] public bool HasUnsavedChanges { get; set; }

    [Parameter] public bool CloseOnBackdrop { get; set; } = true;
    [Parameter] public bool CloseOnEscape { get; set; } = true;

    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }
    [Parameter] public EventCallback OnPrimaryAction { get; set; }

    private ElementReference modalElement;
    private ElementReference? previouslyFocusedElement;
    private string ModalTitleId { get; set; } = $"modal-title-{Guid.NewGuid():N}";
    private string ModalDescriptionId { get; set; } = $"modal-desc-{Guid.NewGuid():N}";

[Inject] private IJSRuntime JSRuntime { get; set; } = default!;
    
protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        

        if (Visible != previousVisible && UseBackdrop)
        {
            if (currentState == ModalState.Closing && Visible)
            {
                throw new InvalidOperationException($"Cannot reopen modal {portalId} while closing");
            }
            
            await stateLock.WaitAsync();
            try
            {
                if (Visible && IsValidTransition(currentState, ModalState.Opening))
                {
                    currentState = ModalState.Opening;
                    
                    modalZIndex = await ModalStack.RegisterModalAsync(portalId);
                    
                    // Wait for DOM to be ready
                    await Task.Yield();
                    
                    var portalCreated = await CreatePortal();
                    if (!portalCreated)
                    {
                        currentState = ModalState.Closed;
                        return;
                    }
                    
                    
                    await CreateFocusTrap();
                    currentState = ModalState.Open;
                }
                else if (!Visible)
                {
                    if (currentState == ModalState.Open)
                    {
                        currentState = ModalState.Closing;
                        
                        try
                        {
                            await DestroyFocusTrap();
                            await CleanupPortal();
                            await ModalStack.UnregisterModalAsync(portalId);
                            currentState = ModalState.Closed;
                        }
                        catch (Exception ex)
                        {
                            await JSRuntime.InvokeVoidAsync("RRBlazor.Portal.cleanupOrphanedElements");
                            currentState = ModalState.Closed;
                        }
                    }
                }
                else
                {
                }
                previousVisible = Visible;
            }
            finally
            {
                stateLock.Release();
            }
        }
        else if (Visible != previousVisible && !UseBackdrop)
        {
            // Handle non-portal modals (e.g., within RModalProvider)
            previousVisible = Visible;
        }
    }
    
    private bool IsValidTransition(ModalState from, ModalState to)
    {
        return (from, to) switch
        {
            (ModalState.Closed, ModalState.Opening) => true,
            (ModalState.Opening, ModalState.Open) => true,
            (ModalState.Open, ModalState.Closing) => true,
            (ModalState.Closing, ModalState.Closed) => true,
            _ => false
        };
    }
    
private async Task<bool> CreatePortal()
    {
        if (isPortalCreated)
        {
            throw new InvalidOperationException($"Portal {portalId} already created");
        }
        
        var dotNetRef = DotNetObjectReference.Create(this);
        
        var options = new
        {
            type = "modal",
            backdrop = UseBackdrop,
            closeOnClickOutside = CloseOnBackdrop,
            closeOnEscape = CloseOnEscape,
            dotNetRef = dotNetRef,
            backdropCallbackMethod = "HandlePortalBackdropClick",
            escapeCallbackMethod = "HandlePortalEscapeKey"
        };
        
        actualPortalId = await JSRuntime.InvokeAsync<string>("RRBlazor.Portal.create", modalElement, options);
        
        if (string.IsNullOrEmpty(actualPortalId))
        {
            throw new InvalidOperationException($"Failed to create portal for modal {portalId}");
        }
        
        isPortalCreated = true;
        return true;
    }
    
private async Task CleanupPortal()
    {
        if (!isPortalCreated)
        {
            return;
        }
        
        if (string.IsNullOrEmpty(actualPortalId))
        {
            isPortalCreated = false;
            return;
        }
        
        var maxRetries = 3;
        var delayMs = 50;
        bool destructionSucceeded = false;
        
        for (int attempt = 0; attempt < maxRetries; attempt++)
        {
            try
            {
                var success = await JSRuntime.InvokeAsync<bool>("RRBlazor.Portal.destroy", actualPortalId);
                
                if (success)
                {
                    destructionSucceeded = true;
                    break;
                }
                
                if (attempt < maxRetries - 1)
                {
                    await Task.Delay(delayMs);
                    delayMs *= 2;
                }
            }
            catch (Exception ex)
            {
                if (attempt == maxRetries - 1)
                {
                    await JSRuntime.InvokeVoidAsync("RRBlazor.Portal.cleanupOrphanedElements");
                    destructionSucceeded = true;
                    break;
                }
                
                await Task.Delay(delayMs);
                delayMs *= 2;
            }
        }
        
        if (destructionSucceeded)
        {
            actualPortalId = null;
            isPortalCreated = false;
        }
        else
        {
            throw new InvalidOperationException($"Failed to cleanup portal {actualPortalId} after {maxRetries} attempts");
        }
    }
    
    private string GetFullViewportStyles()
    {
        return $@"
            z-index: {modalZIndex} !important;
        ";
    }
    
    private string GetModalContainerClasses()
    {
        var positionClass = "modal-center"; // default center positioning
        var backdropClass = Variant == ModalVariant.Glass ? "modal-backdrop-glass" : "modal-backdrop-dark";
        var sizeClass = GetSizeClass();
        var animationSpeedClass = GetAnimationSpeedClass();
        var protectedClass = Variant == ModalVariant.Protected ? "modal-protected" : "";
        
        return $"modal-container modal-backdrop {backdropClass} {positionClass} {sizeClass} {animationSpeedClass} {protectedClass}".Trim();
    }
    
    private string GetAnimationSpeedClass() => AnimationSpeed switch
    {
        AnimationSpeed.UltraFast => "modal-animate-fast",
        AnimationSpeed.Fast => "modal-animate-fast", 
        AnimationSpeed.Slow => "modal-animate-slow",
        AnimationSpeed.VerySlow => "modal-animate-slow",
        _ => "" // normal speed uses default
    };
    
    private async Task OnKeyDownHandler(KeyboardEventArgs e)
    {
        if (e.Key == "Escape" && CloseOnEscape && !Processing && Variant != ModalVariant.Protected && currentState == ModalState.Open)
        {
            if (ModalStack.IsTopModal(portalId))
            {
                await HandleClose();
            }
        }
    }
    
    [JSInvokable]
    public async Task HandlePortalBackdropClick()
    {
        if (CloseOnBackdrop && !Processing && Variant != ModalVariant.Protected && currentState == ModalState.Open)
        {
            // Check if any datepickers are open within this modal
            var hasOpenDatePickers = await JSRuntime.InvokeAsync<bool>("RRBlazor.Portal.hasOpenPortalsInContainer", ".modal-content");
            
            if (hasOpenDatePickers)
            {
                // Don't close modal if datepickers are open - they handle their own backdrop clicks
                return;
            }

            if (ModalStack.IsTopModal(portalId))
            {
                await HandleClose();
            }
        }
    }
    
    [JSInvokable]
    public async Task HandlePortalEscapeKey()
    {
        if (CloseOnEscape && !Processing && Variant != ModalVariant.Protected && currentState == ModalState.Open)
        {
            if (ModalStack.IsTopModal(portalId))
            {
                await HandleClose();
            }
        }
    }
    
    private async Task HandleClose()
    {
        if (!Processing)
        {
            await stateLock.WaitAsync();
            try
            {
                // Don't close if already closing/closed
                if (currentState == ModalState.Closing || currentState == ModalState.Closed)
                {
                    return;
                }
                
                // Perform cleanup for portal-based modals
                if (UseBackdrop && currentState == ModalState.Open)
                {
                    currentState = ModalState.Closing;
                    
                    try
                    {
                        await DestroyFocusTrap();
                        await CleanupPortal();
                        await ModalStack.UnregisterModalAsync(portalId);
                        currentState = ModalState.Closed;
                    }
                    catch (Exception ex)
                    {
                        // Fallback cleanup
                        await JSRuntime.InvokeVoidAsync("RRBlazor.Portal.cleanupOrphanedElements");
                        currentState = ModalState.Closed;
                    }
                }
                
                if (Visible)
                {
                    Visible = false;
                    previousVisible = false; // Update previousVisible to prevent duplicate cleanup
                    await VisibleChanged.InvokeAsync(false);
                }
                
                // Invoke OnClose callback after visibility change
                if (OnClose.HasDelegate)
                {
                    await OnClose.InvokeAsync();
                }
            }
            finally
            {
                stateLock.Release();
            }
        }
    }
    
    private async Task HandleCancel()
    {
        if (!Processing)
        {
            if (OnCancel.HasDelegate)
            {
                await OnCancel.InvokeAsync();
            }
            else
            {
                await HandleClose();
            }
        }
    }
    
    private async Task HandlePrimaryAction()
    {
        if (!Processing && !PrimaryButtonDisabled)
        {
            await OnPrimaryAction.InvokeAsync();
        }
    }
    
    private string GetSizeClass() => Size switch
    {
        ModalSize.Small => "modal-small",
        ModalSize.Large => "modal-large", 
        ModalSize.XLarge => "modal-xlarge",
        ModalSize.Wide => "modal-wide",
        ModalSize.Full => "modal-full",
        _ => "modal-medium" // default medium size
    };
    
    private string GetVisibilityClass() => Visible ? "modal-visible" : "modal-hidden";
    
    private string GetAnimationClass() => Animation switch
    {
        ModalAnimation.Fade => "modal-fade-in",
        ModalAnimation.SlideUp => "modal-slide-up",
        ModalAnimation.SlideUpSmooth => "modal-slide-up",
        ModalAnimation.SlideDown => "modal-slide-down",
        ModalAnimation.SlideLeft => "modal-slide-left",
        ModalAnimation.SlideRight => "modal-slide-right",
        ModalAnimation.DropdownSlideIn => "modal-slide-down",
        ModalAnimation.None => "",
        _ => "modal-scale-in" // default scale animation for Scale, Bounce, Zoom, Flip, Swing
    };

    private string GetModalHeaderClasses()
    {
        // Only return gap classes - padding handled by SCSS .modal-header
        return Density switch
        {
            ComponentDensity.Compact => "gap-2",
            ComponentDensity.Dense => "gap-3",
            ComponentDensity.Normal => "gap-3",
            ComponentDensity.Spacious => "gap-4",
            _ => "gap-3"
        };
    }

    private string GetModalBodyClasses()
    {
        // No padding classes - handled by SCSS .modal-body based on density
        return Density switch
        {
            ComponentDensity.Compact => "modal-body-compact",
            ComponentDensity.Dense => "modal-body-dense",
            ComponentDensity.Normal => "",
            ComponentDensity.Spacious => "modal-body-spacious",
            _ => ""
        };
    }

    private string GetModalFooterClasses()
    {
        // No padding classes - handled by SCSS .modal-footer with dynamic height scaling
        return Density switch
        {
            ComponentDensity.Compact => "modal-footer-compact",
            ComponentDensity.Dense => "modal-footer-dense", 
            ComponentDensity.Normal => "",
            ComponentDensity.Spacious => "modal-footer-spacious",
            _ => ""
        };
    }

    private string GetIconSizeClass()
    {
        return Density switch
        {
            ComponentDensity.Compact => "text-lg",
            ComponentDensity.Dense => "text-xl",
            ComponentDensity.Normal => "text-xl",
            ComponentDensity.Spacious => "text-2xl",
            _ => "text-xl"
        };
    }

    private string GetTitleClasses()
    {
        return Density switch
        {
            ComponentDensity.Compact => "text-base",
            ComponentDensity.Dense => "text-lg",
            ComponentDensity.Normal => "text-lg",
            ComponentDensity.Spacious => "text-xl",
            _ => "text-lg"
        };
    }

    private string GetProcessingOverlayClasses()
    {
        return Density switch
        {
            ComponentDensity.Compact => "pa-3 gap-2",
            ComponentDensity.Dense => "pa-4 gap-3",
            ComponentDensity.Normal => "pa-6 gap-3",
            ComponentDensity.Spacious => "pa-8 gap-4",
            _ => "pa-6 gap-3"
        };
    }
    
    private string GetAnimationStyles()
    {
        var animationProperty = AnimationHelper.GetAnimationProperty(Animation, AnimationSpeed);
        var duration = AnimationHelper.GetDuration(AnimationSpeed);
        var timing = AnimationHelper.GetTimingFunction(AnimationSpeed);
        
        return $"--modal-animation: {animationProperty}; --modal-duration: {duration}; --modal-timing: {timing};";
    }
    
public async ValueTask DisposeAsync()
    {
        await stateLock.WaitAsync();
        try
        {
            if (currentState != ModalState.Closed)
            {
                currentState = ModalState.Closing;
                
                try
                {
                    await DestroyFocusTrap();
                    await CleanupPortal();
                    await ModalStack.UnregisterModalAsync(portalId);
                }
                catch (Exception)
                {
                    try
                    {
                        await JSRuntime.InvokeVoidAsync("RRBlazor.Portal.cleanupOrphanedElements");
                    }
                    catch
                    {
                    }
                }
                finally
                {
                    currentState = ModalState.Closed;
                }
            }
        }
        finally
        {
            stateLock.Release();
            stateLock?.Dispose();
        }
    }
    
    private async Task CreateFocusTrap()
    {
        if (focusTrapActive) return;
        
        await Task.Delay(100);
        
        var success = await JSRuntime.InvokeAsync<bool>("RRBlazor.FocusTrap.create", modalElement, portalId);
        
        if (success)
        {
            focusTrapActive = true;
        }
        else
        {
            throw new InvalidOperationException($"Failed to create focus trap for modal {portalId}");
        }
    }
    
    private async Task DestroyFocusTrap()
    {
        if (!focusTrapActive) return;
        
        var success = await JSRuntime.InvokeAsync<bool>("RRBlazor.FocusTrap.destroy", portalId);
        focusTrapActive = false;
        
        if (!success)
        {
            throw new InvalidOperationException($"Failed to destroy focus trap for modal {portalId}");
        }
    }

    private async Task RestoreFocus()
    {
        await JSRuntime.InvokeVoidAsync("RRBlazor.Modal.blurActiveElement");
    }
    
    #region Abstract Method Implementations
    
    /// <summary>
    /// Gets default size for modals
    /// </summary>
    protected override ModalSize GetDefaultSize() => ModalSize.Medium;
    
    /// <summary>
    /// Gets default variant for modals
    /// </summary>
    protected override ModalVariant GetDefaultVariant() => ModalVariant.Default;
    
    /// <summary>
    /// Provides modal-specific size classes
    /// </summary>
    protected override string GetSizeClasses()
    {
        return GetSizeClass();
    }
    
    /// <summary>
    /// Provides modal-specific variant classes
    /// </summary>
    protected override string GetVariantClasses()
    {
        return Variant switch
        {
            ModalVariant.Confirmation => "modal-confirmation",
            ModalVariant.Destructive => "modal-destructive",
            ModalVariant.Success => "modal-success",
            ModalVariant.Warning => "modal-warning",
            ModalVariant.Info => "modal-info",
            ModalVariant.Glass => "modal-glass",
            ModalVariant.Protected => "modal-protected",
            _ => "modal-default"
        };
    }
    
    /// <summary>
    /// Provides modal-specific text size classes
    /// </summary>
    protected override string GetTextSizeClasses()
    {
        return "text-xl";
    }
    
    /// <summary>
    /// Provides modal-specific icon size classes
    /// </summary>
    protected override string GetIconSizeClasses()
    {
        return "text-2xl";
    }
    
    #endregion
}
