@using RR.Blazor.Services
@inject IToastService ToastService
@implements IDisposable

<div class="toast-container toast-container--@GetPositionClass()">
    @if (toasts.Any())
    {
        var orderedToasts = ToastService.Options.NewestOnTop ? toasts.AsEnumerable().Reverse() : toasts;
        @foreach (var toast in orderedToasts)
        {
            <div class="toast toast--@(toast.Type.ToString().ToLower()) toast--@(GetToastState(toast.Id))" 
                 @key="toast.Id">
                <div class="toast__icon">
                    @if (!string.IsNullOrEmpty(toast.Icon))
                    {
                        <i class="material-symbols-rounded">@toast.Icon</i>
                    }
                    else
                    {
                        <i class="material-symbols-rounded">@GetDefaultIcon(toast.Type)</i>
                    }
                </div>
                <div class="toast__content">
                    @if (!string.IsNullOrEmpty(toast.Title))
                    {
                        <h5 class="toast__title">@toast.Title</h5>
                    }
                    <p class="toast__message">@toast.Message</p>
                    @if (!string.IsNullOrEmpty(toast.ActionText) && toast.OnAction != null)
                    {
                        <button class="toast__action" @onclick="() => HandleAction(toast)">
                            @toast.ActionText
                        </button>
                    }
                </div>
                @if (toast.ShowCloseButton)
                {
                    <button class="toast__close" @onclick="() => RemoveToast(toast.Id)" aria-label="Close notification">
                        <i class="material-symbols-rounded">close</i>
                    </button>
                }
            </div>
        }
    }
</div>

@code {
    private readonly List<ToastMessage> toasts = new();
    private readonly Dictionary<string, Timer> timers = new();
    private readonly Dictionary<string, string> toastStates = new();
    private readonly HashSet<string> removingToasts = new();
    private readonly SemaphoreSlim semaphore = new(1, 1);
    
    protected override void OnInitialized()
    {
        ToastService.OnShow += HandleToastShow;
        ToastService.OnRemove += HandleToastRemove;
        ToastService.OnClearAll += HandleClearAll;
    }
    
    private void HandleToastShow(ToastMessage toast)
    {
        InvokeAsync(async () =>
        {
            await semaphore.WaitAsync();
            try
            {
                // Remove oldest toasts if we have too many
                while (toasts.Count >= ToastService.Options.MaxToasts)
                {
                    var toastToRemove = ToastService.Options.NewestOnTop 
                        ? toasts.First() 
                        : toasts.Last();
                    await RemoveToastInternal(toastToRemove.Id, false);
                }
                
                // Add new toast
                if (ToastService.Options.NewestOnTop)
                {
                    toasts.Add(toast);
                }
                else
                {
                    toasts.Insert(0, toast);
                }
                
                toastStates[toast.Id] = "entering";
                StateHasChanged();
                
                // Trigger animation to visible state
                await Task.Delay(50);
                if (toastStates.ContainsKey(toast.Id))
                {
                    toastStates[toast.Id] = "visible";
                    StateHasChanged();
                }
                
                // Set up auto-remove timer if duration > 0
                if (toast.Duration > 0)
                {
                    var timer = new Timer(
                        _ => InvokeAsync(() => RemoveToast(toast.Id)), 
                        null, 
                        TimeSpan.FromMilliseconds(toast.Duration), 
                        Timeout.InfiniteTimeSpan
                    );
                    timers[toast.Id] = timer;
                }
            }
            finally
            {
                semaphore.Release();
            }
        });
    }
    
    private void HandleToastRemove(string id)
    {
        InvokeAsync(() => RemoveToastInternal(id, true));
    }
    
    private void HandleClearAll()
    {
        InvokeAsync(async () =>
        {
            await semaphore.WaitAsync();
            try
            {
                // Clean up all timers
                foreach (var timer in timers.Values)
                {
                    timer.Dispose();
                }
                timers.Clear();
                
                // Clear all toasts
                toasts.Clear();
                toastStates.Clear();
                removingToasts.Clear();
                StateHasChanged();
            }
            finally
            {
                semaphore.Release();
            }
        });
    }
    
    private void RemoveToast(string toastId)
    {
        ToastService.Remove(toastId);
    }
    
    private async Task RemoveToastInternal(string toastId, bool animate)
    {
        await semaphore.WaitAsync();
        try
        {
            // Prevent double removal
            if (removingToasts.Contains(toastId))
                return;
            
            removingToasts.Add(toastId);
            
            // Animate out if requested
            if (animate && toastStates.ContainsKey(toastId))
            {
                toastStates[toastId] = "exiting";
                StateHasChanged();
                await Task.Delay(300); // Wait for animation
            }
            
            // Remove from collections
            var toast = toasts.FirstOrDefault(t => t.Id == toastId);
            if (toast != null)
            {
                toasts.Remove(toast);
            }
            
            toastStates.Remove(toastId);
            removingToasts.Remove(toastId);
            StateHasChanged();
            
            // Clean up timer
            if (timers.TryGetValue(toastId, out var timer))
            {
                timer.Dispose();
                timers.Remove(toastId);
            }
        }
        finally
        {
            semaphore.Release();
        }
    }
    
    private void HandleAction(ToastMessage toast)
    {
        toast.OnAction?.Invoke();
        RemoveToast(toast.Id);
    }
    
    private string GetToastState(string toastId)
    {
        return toastStates.TryGetValue(toastId, out var state) ? state : "entering";
    }
    
    private string GetPositionClass()
    {
        return ToastService.Options.Position switch
        {
            ToastPosition.TopLeft => "top-left",
            ToastPosition.TopCenter => "top-center",
            ToastPosition.TopRight => "top-right",
            ToastPosition.BottomLeft => "bottom-left",
            ToastPosition.BottomCenter => "bottom-center",
            ToastPosition.BottomRight => "bottom-right",
            _ => "top-right"
        };
    }
    
    private string GetDefaultIcon(ToastType type) => type switch
    {
        ToastType.Success => "check_circle",
        ToastType.Error => "error",
        ToastType.Warning => "warning",
        ToastType.Info => "info",
        _ => "info"
    };
    
    public void Dispose()
    {
        ToastService.OnShow -= HandleToastShow;
        ToastService.OnRemove -= HandleToastRemove;
        ToastService.OnClearAll -= HandleClearAll;
        
        foreach (var timer in timers.Values)
        {
            timer.Dispose();
        }
        timers.Clear();
        toastStates.Clear();
        removingToasts.Clear();
        semaphore.Dispose();
    }
}

@* 
Usage Example:

// In Program.cs:
builder.Services.AddRRToast(options =>
{
    options.Position = ToastPosition.TopRight;
    options.MaxToasts = 5;
    options.DefaultDuration = 4000;
});

// In MainLayout.razor or App.razor:
<RToastContainer />

// In any component:
@inject IToastService ToastService

ToastService.ShowSuccess("Record saved successfully!");
ToastService.ShowError("Failed to save record", "Error");
ToastService.Show(new ToastMessage 
{
    Type = ToastType.Info,
    Title = "New Update",
    Message = "A new version is available",
    ActionText = "Update Now",
    OnAction = () => Navigation.NavigateTo("/update"),
    Duration = 0 // Don't auto-hide
});
*@