@namespace RR.Blazor.Components
@using RR.Blazor.Enums
@using RR.Blazor.Components.Base
@using Microsoft.AspNetCore.Components
@inherits RForwardingComponentBase
@inject IJSRuntime JS

@if (SmartMode && ChildContent != null)
{
    @* Smart mode: Wrap content and show skeleton overlay when loading *@
    @if (Loading)
    {
        <div class="skeleton-smart-wrapper @Class" @ref="skeletonContainer" @attributes="GetSafeAttributes()">
            <div class="skeleton-smart-container skeleton-hidden-container">
                @ChildContent
            </div>
            @RenderSmartSkeleton()
        </div>
    }
    else
    {
        @* Smart mode not loading: Show actual content *@
        @ChildContent
    }
}
else
{
    @* Non-smart mode: Show skeleton only when loading *@
    @if (Loading)
    {
        <div class="@GetContainerClasses()" @ref="skeletonContainer" @attributes="GetSafeAttributes()">
            @if (Count > 1)
            {
                @for (int i = 0; i < Count; i++)
                {
                    <div class="@GetWrapperClasses()">
                        @RenderSkeleton()
                    </div>
                }
            }
            else
            {
                @RenderSkeleton()
            }
        </div>
    }
    else if (ChildContent != null)
    {
        @* Not loading - show actual content *@
        @ChildContent
    }
}

@code {
    [Parameter] public SkeletonType Type { get; set; } = SkeletonType.Smart;
    [Parameter] public string Width { get; set; } = "100%";
    [Parameter] public string Height { get; set; } = "auto";
    [Parameter] public int Count { get; set; } = 1;
    [Parameter] public bool Animated { get; set; } = true;
    [Parameter] public bool Loading { get; set; } = true;
    [Parameter] public bool SmartMode { get; set; } = true;
    [Parameter] public bool UseGlassEffect { get; set; } = false;
    
    private ElementReference skeletonContainer;
    private List<SkeletonElement> detectedElements = new();
    private bool _isAnalyzed = false;
    private string _generatedSkeletonHTML = string.Empty;

    private RenderFragment RenderSkeleton() => Type switch
    {
        SkeletonType.Smart => RenderSmartSkeleton(),
        SkeletonType.Text => RenderTextSkeleton(),
        SkeletonType.Title => RenderTitleSkeleton(),
        SkeletonType.Avatar => RenderAvatarSkeleton(),
        SkeletonType.Card => RenderCardSkeleton(),
        SkeletonType.Table => RenderTableSkeleton(),
        SkeletonType.Custom => ChildContent ?? RenderSmartSkeleton(),
        _ => RenderSmartSkeleton()
    };
    
    private RenderFragment RenderSmartSkeleton() => 
        @<text>
            @if (!string.IsNullOrEmpty(_generatedSkeletonHTML))
            {
                @((MarkupString)_generatedSkeletonHTML)
            }
            else if (detectedElements.Any())
            {
                @foreach (var element in detectedElements)
                {
                    @RenderSkeletonElement(element)
                }
            }
            else
            {
                @* No fallback - show nothing if no skeleton generated *@
            }
        </text>;
        
    private RenderFragment RenderSkeletonElement(SkeletonElement element) =>
        @<div class="@GetSkeletonClasses() @element.CssClass" 
              style="@element.Style">
            @if (element.Children?.Any() == true)
            {
                @foreach (var child in element.Children)
                {
                    @RenderSkeletonElement(child)
                }
            }
        </div>;

    private RenderFragment RenderTextSkeleton() => @<div class="@GetSkeletonClasses() skeleton-text" style="@GetSkeletonStyle()" aria-hidden="true" role="presentation"></div>;

    private RenderFragment RenderTitleSkeleton() => @<div class="@GetSkeletonClasses() skeleton-title" style="@GetSkeletonStyle()" aria-hidden="true" role="presentation"></div>;

    private RenderFragment RenderAvatarSkeleton() => 
        @<div class="flex items-center gap-3" aria-hidden="true" role="presentation">
            <div class="@GetSkeletonClasses() skeleton-avatar"></div>
            <div class="grow">
                <div class="@GetSkeletonClasses() skeleton-text mb-2 w-60"></div>
                <div class="@GetSkeletonClasses() skeleton-text w-40"></div>
            </div>
        </div>;

    private RenderFragment RenderCardSkeleton() => 
        @<div class="skeleton-card" aria-hidden="true" role="presentation">
            <div class="@GetSkeletonClasses() skeleton-title mb-4"></div>
            <div class="@GetSkeletonClasses() skeleton-text mb-2"></div>
            <div class="@GetSkeletonClasses() skeleton-text mb-2 w-80"></div>
            <div class="@GetSkeletonClasses() skeleton-text w-60"></div>
        </div>;

    private RenderFragment RenderTableSkeleton() =>
        @<div class="border border-light rounded-md overflow-hidden" aria-hidden="true" role="presentation">
            <div class="pa-3 bg-surface-elevated border-b border-light">
                <div class="@GetSkeletonClasses() skeleton-text"></div>
            </div>
            @for (int i = 0; i < 5; i++)
            {
                <div class="pa-3 border-b border-light">
                    <div class="@GetSkeletonClasses() skeleton-text"></div>
                </div>
            }
        </div>;

    private string GetSkeletonClasses()
    {
        var classes = new List<string> { "skeleton" };
        
        // Apply shimmer animation by default when Animated is true
        if (Animated)
        {
            classes.Add("skeleton-shimmer");
        }
        
        return string.Join(" ", classes);
    }
    
    private Dictionary<string, object> GetSkeletonAttributes()
    {
        var attributes = new Dictionary<string, object>
        {
            ["aria-hidden"] = "true",
            ["role"] = "presentation"
        };
        
        return attributes;
    }

    private string GetWrapperClasses()
    {
        return Type switch
        {
            SkeletonType.Card => "mb-4",
            SkeletonType.Table => "mb-6",
            _ => "mb-2"
        };
    }
    
    private string GetContainerClasses()
    {
        var classes = new List<string>();
        
        if (!string.IsNullOrEmpty(Class))
        {
            classes.Add(Class);
        }
        
        return string.Join(" ", classes);
    }

    private string GetSkeletonStyle()
    {
        var styles = new List<string>();
        
        if (Width != "100%")
        {
            styles.Add($"--dynamic-width: {Width}");
        }
        
        if (Height != "auto")
        {
            styles.Add($"--dynamic-height: {Height}");
        }
        
        return string.Join("; ", styles);
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (SmartMode && ChildContent != null && Loading && !_isAnalyzed)
        {
            await AnalyzeContent();
        }
        
        // Reset analysis state when not loading to allow re-analysis on next load
        if (!Loading)
        {
            _isAnalyzed = false;
            _generatedSkeletonHTML = string.Empty;
            detectedElements.Clear();
        }
    }
    
    private async Task AnalyzeContent()
    {
        if (_isAnalyzed) return;
        
        try
        {
            _isAnalyzed = true;
            
            // Use JavaScript interop to analyze the actual hidden content via RR.Blazor proxy
            var skeletonHTML = await JS.InvokeAsync<string>("RRBlazor.Skeleton.generateSkeletonHTML", skeletonContainer, Animated);
            
            if (!string.IsNullOrEmpty(skeletonHTML))
            {
                await ParseSkeletonHTML(skeletonHTML);
            }
            else
            {
                _generatedSkeletonHTML = string.Empty;
                detectedElements.Clear();
            }
            
            await InvokeAsync(StateHasChanged);
        }
        catch
        {
            // Fallback to simple skeleton on error
            await GenerateSmartSkeleton();
        }
    }
    
    private async Task ParseSkeletonHTML(string skeletonHTML)
    {
        try
        {
            // Parse the HTML and convert to SkeletonElement objects
            // For now, we'll render the HTML directly via markup string
            _generatedSkeletonHTML = skeletonHTML;
            detectedElements.Clear(); // Clear since we're using raw HTML
        }
        catch
        {
            await GenerateSmartSkeleton();
        }
    }
    
    private async Task GenerateSmartSkeleton()
    {
        var shimmerClass = Animated ? " skeleton-shimmer" : "";
        detectedElements = new List<SkeletonElement>
        {
            new() { Type = "text", CssClass = $"skeleton skeleton-title mb-3{shimmerClass}", Style = "width: 40%; height: 1.5rem;" },
            new() { Type = "text", CssClass = $"skeleton skeleton-text mb-2{shimmerClass}", Style = "width: 100%; height: 1rem;" },
            new() { Type = "text", CssClass = $"skeleton skeleton-text mb-2{shimmerClass}", Style = "width: 85%; height: 1rem;" },
            new() { Type = "text", CssClass = $"skeleton skeleton-text mb-4{shimmerClass}", Style = "width: 70%; height: 1rem;" },
            new() { Type = "badge", CssClass = $"skeleton skeleton-badge{shimmerClass}", Style = "width: 4rem; height: 1.5rem; border-radius: 0.75rem;" }
        };
        _generatedSkeletonHTML = string.Empty;
    }
    
    public class SkeletonElement
    {
        public string Type { get; set; } = "text";
        public string CssClass { get; set; } = "skeleton-text";
        public string Style { get; set; } = "";
        public List<SkeletonElement> Children { get; set; } = new();
    }
}

@*
Usage Examples:

<!-- Smart Auto-Detection Mode (Default) -->
<RSkeleton Loading="@isLoading">
    <div>
        <div class="text-h6 font-semibold">Content Title</div>
        <p class="text-muted mb-3">This is some content text.</p>
        <RChip Text="Status" StyleVariant="ChipStyle.Badge" />
    </div>
</RSkeleton>

<!-- Manual Type Mode -->
<RSkeleton Type="SkeletonType.Card" Loading="@isLoading" SmartMode="false" />

<!-- Multiple Skeletons -->
<RSkeleton Type="SkeletonType.Text" Count="3" Loading="@isLoading" SmartMode="false" />
*@