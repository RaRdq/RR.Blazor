@** 
<summary>
Generic autosuggest component with dropdown suggestions and search functionality.
Extensible foundation for text search, datepicker autosuggest, and custom implementations.
</summary>
<category>Form</category>
<complexity>Complex</complexity>
<ai-prompt>Create autosuggest input with dropdown suggestions</ai-prompt>
<ai-common-use>search inputs, autocomplete fields, suggestion dropdowns</ai-common-use>
<ai-avoid>Don't use for simple inputs without suggestions. Use RTextInput instead.</ai-avoid>
**@

@namespace RR.Blazor.Components
@using RR.Blazor.Models
@using RR.Blazor.Enums
@using RR.Blazor.Attributes
@using Microsoft.AspNetCore.Components.Web
@typeparam TItem where TItem : notnull
@inherits RInputBase
@implements IAsyncDisposable
@inject IJSRuntime JS

@attribute [Component("RAutosuggestGeneric", Category = "Form", Complexity = ComponentComplexity.Complex)]
@attribute [AIOptimized(Prompt = "Create autosuggest input with dropdown suggestions", 
                       CommonUse = "search inputs, autocomplete fields, suggestion dropdowns", 
                       AvoidUsage = "Don't use for simple inputs without suggestions")]

<div class="@GetAutosuggestClasses()" 
     tabindex="-1"
     data-autosuggest-id="@ElementId"
     @onkeydown="HandleKeyDown">

    <!-- Input Field -->
    <RTextInput Value="@SearchQuery"
               ValueChanged="@HandleValueChanged"
               Type="@InputType"
               Placeholder="@Placeholder"
               Label="@Label"
               HelpText="@HelpText" 
               Size="@GetTextInputSize()"
               Disabled="@Disabled"
               ReadOnly="@ReadOnly"
               Required="@Required"
               Class="@GetInputClasses()"
               StartIcon="@GetEffectiveStartIcon()"
               EndIcon="@GetEndIcon()"
               OnFocus="@HandleInputFocus"
               OnBlur="@HandleInputBlur"
               AdditionalAttributes="@GetInputAttributes()" />

    <!-- Suggestions Dropdown - Always rendered for portal movement -->
    <div class="autosuggest-backdrop @(IsOpen ? "visible" : "hidden")" @onclick="CloseDropdown"></div>
    
    <div class="autosuggest-viewport @(IsOpen ? "visible" : "hidden")">
        <div class="autosuggest-dropdown">
            @if (IsOpen)
            {
                @if (ShowLoading && IsLoading)
                {
                    <div class="autosuggest-loading">
                        <div class="search-loading-indicator">
                            <i class="icon animate-spin">refresh</i>
                            <span class="text-sm text-muted">Searching...</span>
                        </div>
                        <RSkeleton Height="2rem" />
                        <RSkeleton Height="2rem" />
                        <RSkeleton Height="2rem" />
                    </div>
                }
                else if (FilteredItems.Any())
                {
                    @foreach (var (item, index) in FilteredItems.Take(MaxSuggestions).Select((item, idx) => (item, idx)))
                    {
                        <div class="autosuggest-item @GetItemClasses(index)"
                             @onclick="() => HandleItemSelect(item)"
                             @onmouseenter="() => SetSelectedIndex(index)"
                             data-item-index="@index"
                             role="option"
                             aria-selected="@(SelectedIndex == index)">
                            @if (ItemTemplate != null)
                            {
                                @ItemTemplate(item)
                            }
                            else
                            {
                                <div class="autosuggest-item-content">
                                    @if (!string.IsNullOrEmpty(GetItemIcon(item)))
                                    {
                                        <i class="icon autosuggest-item-icon">@GetItemIcon(item)</i>
                                    }
                                    <span class="autosuggest-item-text">@GetItemText(item)</span>
                                </div>
                            }
                        </div>
                    }
                }
                else if (!string.IsNullOrWhiteSpace(SearchQuery) && SearchQuery.Length >= MinSearchLength)
                {
                    <div class="autosuggest-empty">
                        @if (EmptyTemplate != null)
                        {
                            @EmptyTemplate
                        }
                        else
                        {
                            <div class="autosuggest-empty-content">
                                <i class="icon">search_off</i>
                                <span>No suggestions found</span>
                            </div>
                        }
                    </div>
                }
            }
        </div>
    </div>
</div>

@code {
    private string searchQuery = string.Empty;
    private bool isOpen;
    private bool isLoading;
    private int selectedIndex = -1;
    private Timer debounceTimer;
    private CancellationTokenSource cancellationTokenSource;
    private int searchGeneration = 0;
    private string portalId;
    private string currentDirection = "down";
    private bool disposed = false;

    [Parameter] public TItem Value { get; set; }
    [Parameter] public EventCallback<TItem> ValueChanged { get; set; }
    [Parameter] public IEnumerable<TItem> Items { get; set; } = Enumerable.Empty<TItem>();
    [Parameter] public Func<string, CancellationToken, Task<IEnumerable<TItem>>> SearchFunc { get; set; }
    [Parameter] public Func<TItem, string> ItemTextSelector { get; set; } = item => item?.ToString() ?? string.Empty;
    [Parameter] public Func<TItem, string> ItemIconSelector { get; set; }
    [Parameter] public RenderFragment<TItem> ItemTemplate { get; set; }
    [Parameter] public RenderFragment EmptyTemplate { get; set; }
    [Parameter] public int MinSearchLength { get; set; } = 1;
    [Parameter] public int DebounceDelay { get; set; } = 300;
    [Parameter] public int MaxSuggestions { get; set; } = 10;
    [Parameter] public bool ShowLoading { get; set; } = true;
    [Parameter] public bool ClearOnSelect { get; set; }
    [Parameter] public bool OpenOnFocus { get; set; }
    [Parameter] public FieldType InputType { get; set; } = FieldType.Text;
    [Parameter] public string ElementId { get; set; } = $"autosuggest-{Guid.NewGuid():N}";

    [Parameter] public string Icon { get; set; }
    [Parameter] public bool ShowDropdownIcon { get; set; } = true;

    [Parameter] public EventCallback<TItem> OnItemSelected { get; set; }
    [Parameter] public EventCallback<string> OnSearchChanged { get; set; }
    
    // Universal Portal Interface Parameters
    [Parameter] public bool UseBackdrop { get; set; } = false;
    [Parameter] public string BackdropClass { get; set; } = "";
    [Parameter] public bool CloseOnBackdropClick { get; set; } = true;
    [Parameter] public bool CloseOnEscape { get; set; } = true;
    [Parameter] public bool CloseOnClickOutside { get; set; } = true;

    private string SearchQuery
    {
        get => searchQuery;
        set => searchQuery = value;
    }

    private bool IsOpen => isOpen && !Disabled && !ReadOnly;
    private bool IsLoading => isLoading;
    private int SelectedIndex => selectedIndex;
    private IEnumerable<TItem> FilteredItems => Items ?? Enumerable.Empty<TItem>();

    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (Value != null)
        {
            searchQuery = GetItemText(Value);
        }
    }


    private async Task HandleValueChanged(string value)
    {
        if (searchQuery == value) return;
        
        searchQuery = value;
        await OnSearchChanged.InvokeAsync(value);
        await HandleSearch();
    }

    private async Task HandleInputFocus()
    {
        if (OpenOnFocus && !IsOpen && !string.IsNullOrWhiteSpace(SearchQuery))
        {
            await OpenDropdown();
        }
    }

    private async Task HandleInputBlur()
    {

        await Task.Yield(); // Let Blazor complete render cycle
        await CloseDropdown();
    }

    private async Task HandleSearch()
    {
        cancellationTokenSource?.Cancel();
        debounceTimer?.Dispose();

        if (string.IsNullOrWhiteSpace(searchQuery) || searchQuery.Length < MinSearchLength)
        {
            await CloseDropdown();
            return;
        }

        searchGeneration++;
        var currentGeneration = searchGeneration;
        
        if (!isLoading)
        {
            isLoading = true;
        }

        cancellationTokenSource = new CancellationTokenSource();
        debounceTimer = new Timer(async _ =>
        {
            if (disposed) return;
            
            await InvokeAsync(async () =>
            {
                if (disposed || SearchFunc == null || currentGeneration != searchGeneration) return;

                if (SearchFunc != null)
                {
                    try
                    {
                        var results = await SearchFunc(searchQuery, cancellationTokenSource.Token);
                        if (!disposed && currentGeneration == searchGeneration)
                        {
                            Items = results ?? Enumerable.Empty<TItem>();
                            
                            if (!isOpen)
                            {
                                isOpen = true;
                                selectedIndex = -1;
                            }
                        }
                    }
                    catch (OperationCanceledException) { }
                    finally
                    {
                        if (!disposed && currentGeneration == searchGeneration)
                        {
                            isLoading = false;
                            StateHasChanged();
                        }
                    }
                }
                else
                {
                    if (!disposed && currentGeneration == searchGeneration)
                    {
                        if (!isOpen)
                        {
                            isOpen = true;
                            selectedIndex = -1;
                        }
                        isLoading = false;
                        StateHasChanged();
                    }
                }
            });
        }, null, DebounceDelay, Timeout.Infinite);
    }

    private async Task HandleItemSelect(TItem item)
    {
        Value = item;
        searchQuery = ClearOnSelect ? string.Empty : GetItemText(item);
        await CloseDropdown();
        await ValueChanged.InvokeAsync(item);
        await OnItemSelected.InvokeAsync(item);
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (!IsOpen || !FilteredItems.Any() || disposed) return;

        var needsStateChange = false;
        var newSelectedIndex = selectedIndex;

        switch (e.Key)
        {
            case "ArrowDown":
                newSelectedIndex = Math.Min(selectedIndex + 1, FilteredItems.Count() - 1);
                if (newSelectedIndex != selectedIndex)
                {
                    selectedIndex = newSelectedIndex;
                    needsStateChange = true;
                }
                break;

            case "ArrowUp":
                newSelectedIndex = Math.Max(selectedIndex - 1, -1);
                if (newSelectedIndex != selectedIndex)
                {
                    selectedIndex = newSelectedIndex;
                    needsStateChange = true;
                }
                break;

            case "Enter":
                if (selectedIndex >= 0 && selectedIndex < FilteredItems.Count())
                {
                    await HandleItemSelect(FilteredItems.ElementAt(selectedIndex));
                }
                break;

            case "Escape":
                if (CloseOnEscape)
                {
                    await CloseDropdown();
                }
                break;
        }

        if (needsStateChange && !disposed)
        {
            StateHasChanged();
        }
    }


    private async Task OpenDropdown()
    {
        if (!isOpen)
        {
            isOpen = true;
            selectedIndex = -1;
            StateHasChanged();
            
            // Allow DOM to update before creating portal
            await Task.Yield();
            
            // Create portal for positioning
            await CreatePortal();
            
            // Update direction after portal is positioned
            await Task.Yield(); // Allow portal positioning to complete
            await UpdateCurrentDirection();
        }
    }

    private async Task CloseDropdown()
    {
        if (isOpen)
        {
            isOpen = false;
            selectedIndex = -1;
            
            // Destroy portal
            await DestroyPortal();
            
            StateHasChanged();
        }
    }

    private async Task CreatePortal()
    {
        if (!string.IsNullOrEmpty(portalId)) return;
        
        try
        {
            var portalConfig = new
            {
                useBackdrop = UseBackdrop,
                backdropClass = BackdropClass,
                closeOnBackdropClick = CloseOnBackdropClick,
                closeOnEscape = CloseOnEscape
            };
            
            portalId = await SafeInvokeAsync<string>("RRBlazor.Autosuggest.createPortal", ElementId, portalConfig);
            
            if (!string.IsNullOrEmpty(portalId))
            {
                await UpdateCurrentDirection();
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Portal creation failed: {ex.Message}");
        }
    }

    private async Task DestroyPortal()
    {
        if (string.IsNullOrEmpty(portalId)) return;
        
        try
        {
            await SafeInvokeAsync("RRBlazor.Autosuggest.destroyPortal", portalId);
            portalId = null;
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Portal cleanup failed: {ex.Message}");
        }
    }

    private void SetSelectedIndex(int index)
    {
        selectedIndex = index;
    }

    private string GetItemText(TItem item) => ItemTextSelector?.Invoke(item) ?? item?.ToString() ?? string.Empty;
    private string GetItemIcon(TItem item) => ItemIconSelector?.Invoke(item) ?? string.Empty;

    private string GetEffectiveStartIcon()
    {

        return !string.IsNullOrEmpty(StartIcon) ? StartIcon : Icon;
    }

    private string GetEndIcon()
    {
        if (IsLoading) return "refresh";
        if (!string.IsNullOrEmpty(EndIcon)) return EndIcon;
        
        if (!ShowDropdownIcon) return string.Empty;
        
        if (IsOpen)
        {
            return currentDirection == "up" ? "expand_less" : "expand_more";
        }
        
        return "expand_more";
    }

    private async Task UpdateCurrentDirection()
    {
        if (string.IsNullOrEmpty(ElementId) || disposed) return;
        
        try
        {
            var newDirection = await SafeInvokeAsync<string>("RRBlazor.Autosuggest.getDirection", ElementId);
            if (!disposed && !string.IsNullOrEmpty(newDirection) && currentDirection != newDirection)
            {
                currentDirection = newDirection;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Warning: Failed to get autosuggest direction: {ex.Message}");
        }
    }


    private string GetAutosuggestClasses()
    {
        var classes = new List<string> { "autosuggest", "relative" };
        
        if (IsOpen) classes.Add("autosuggest-open");
        if (IsLoading) classes.Add("autosuggest-loading");
        if (Disabled) classes.Add("autosuggest-disabled");
        if (!string.IsNullOrEmpty(Class)) classes.Add(Class);
        
        return string.Join(" ", classes);
    }

    private string GetInputClasses()
    {
        var classes = new List<string> { "autosuggest-input" };
        
        // Icon padding classes are handled by the underlying RTextInput component
        // The RTextInput will automatically add input-with-start-icon and input-with-end-icon
        // based on the StartIcon and EndIcon parameters we pass to it
        
        return string.Join(" ", classes);
    }

    private string GetItemClasses(int index)
    {
        var classes = new List<string> { "autosuggest-item" };
        if (index == selectedIndex) classes.Add("autosuggest-item-selected");
        return string.Join(" ", classes);
    }

    private Dictionary<string, object> GetInputAttributes()
    {
        var attrs = new Dictionary<string, object>();
        
        if (IsOpen)
        {
            attrs.Add("aria-expanded", "true");
            attrs.Add("aria-haspopup", "listbox");
            attrs.Add("role", "combobox");
        }
        
        return attrs;
    }

    private SizeType GetTextInputSize() => Size;

    [JSInvokable]
    public async Task OnClickOutside()
    {
        if (IsOpen && CloseOnBackdropClick)
        {
            await CloseDropdown();
        }
    }
    
    [JSInvokable]
    public async Task HandleBackdropClick()
    {
        if (CloseOnBackdropClick)
        {
            await CloseDropdown();
        }
    }
    
    [JSInvokable]
    public async Task HandleEscapeKey()
    {
        if (CloseOnEscape)
        {
            await CloseDropdown();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (disposed) return;
        disposed = true;
        
        // Clean up timers and cancellation tokens first
        debounceTimer?.Dispose();
        cancellationTokenSource?.Cancel();
        cancellationTokenSource?.Dispose();
        
        // Clean up portal
        await DestroyPortal();
        
        debounceTimer = null;
        cancellationTokenSource = null;
    }
}