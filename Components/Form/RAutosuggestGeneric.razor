@** 
<summary>
Generic autosuggest component that wraps RChoice with search input trigger.
Reuses RChoice's dropdown body and portal system.
</summary>
<category>Form</category>
<complexity>Complex</complexity>
**@

@namespace RR.Blazor.Components
@using RR.Blazor.Models
@using RR.Blazor.Enums
@using RR.Blazor.Attributes
@using RR.Blazor.Components.Base
@using RR.Blazor.Components.Form
@using Microsoft.JSInterop
@typeparam TItem where TItem : notnull
@inherits RComponentBase
@inject IJSRuntime JS
@implements IAsyncDisposable

@attribute [Component("RAutosuggestGeneric", Category = "Form", Complexity = ComponentComplexity.Complex)]

<div class="autosuggest @GetAutosuggestClasses()" 
     data-autosuggest-id="@autosuggestId"
     @ref="containerRef">

    <RTextInput Value="@SearchQuery"
               ValueChanged="@HandleValueChanged"
               Type="@InputType"
               Placeholder="@Placeholder"
               Label="@Label"
               HelpText="@HelpText" 
               Size="@Size"
               Disabled="@Disabled"
               ReadOnly="@ReadOnly"
               Required="@Required"
               Class="@GetTriggerContainerClasses()"
               InputClass="@GetTriggerInputClasses()"
               FullWidth="true"
               DisableHoverEffects="true"
               StartIcon="@GetEffectiveStartIcon()"
               EndIcon="@GetEndIcon()"
               OnFocus="@HandleInputFocus"
               OnBlur="@HandleInputBlur"
               OnClick="HandleInputClick"
               @onkeydown="@HandleKeyDown"
               AdditionalAttributes="@GetTriggerAttributes()"
               @ref="inputRef" />

    <div class="autosuggest-viewport @(isDropdownOpen ? "autosuggest-viewport-open" : "autosuggest-viewport-closed")" 
         @ref="dropdownRef">
        <div class="autosuggest-dropdown">
            @if (ShowLoading && IsLoading && isDropdownOpen)
            {
                <div class="autosuggest-loading">
                    <div class="loading-indicator">
                        <i class="icon animate-spin">refresh</i>
                        <span>Searching...</span>
                    </div>
                </div>
            }
            else if (FilteredItems.Any())
            {
                var itemsToShow = FilteredItems.Take(EnableVirtualization ? MaxItemsToShow : MaxSuggestions);
                @foreach (var (item, index) in itemsToShow.Select((item, idx) => (item, idx)))
                {
                    <div class="autosuggest-item @GetItemClasses(index)"
                         @onclick="() => HandleItemSelect(item)"
                         @onmouseenter="() => SetSelectedIndex(index)"
                         data-item-index="@index">
                        @if (ItemTemplate != null)
                        {
                            @ItemTemplate(item)
                        }
                        else
                        {
                            <div class="autosuggest-item-content">
                                @if (!string.IsNullOrEmpty(GetItemIcon(item)))
                                {
                                    <i class="icon">@GetItemIcon(item)</i>
                                }
                                <span>@GetItemText(item)</span>
                            </div>
                        }
                    </div>
                }
            }
            else if (!string.IsNullOrWhiteSpace(SearchQuery) && SearchQuery.Length >= MinSearchLength)
            {
                <div class="autosuggest-empty">
                    @if (EmptyTemplate != null)
                    {
                        @EmptyTemplate
                    }
                    else
                    {
                        <div class="empty-content">
                            <i class="icon">search_off</i>
                            <span>No results found</span>
                        </div>
                    }
                </div>
            }
        </div>
    </div>
</div>

@code {
    private ElementReference containerRef;
    private ElementReference dropdownRef;
    private RTextInput inputRef;
    private string searchQuery = string.Empty;
    private bool isLoading;
    private int selectedIndex = -1;
    private Timer debounceTimer;
    private CancellationTokenSource cancellationTokenSource;
    private int searchGeneration = 0;
    private bool isDropdownOpen;
    private string autosuggestId = $"autosuggest-{Guid.NewGuid():N}";
    private IJSObjectReference? autosuggestModule;
    private DotNetObjectReference<RAutosuggestGeneric<TItem>>? dotNetRef;

    [Parameter] public TItem Value { get; set; }
    [Parameter] public EventCallback<TItem> ValueChanged { get; set; }
    [Parameter] public IEnumerable<TItem> Items { get; set; } = Enumerable.Empty<TItem>();
    [Parameter] public Func<string, CancellationToken, Task<IEnumerable<TItem>>> SearchFunc { get; set; }
    [Parameter] public Func<TItem, string> ItemTextSelector { get; set; } = item => item?.ToString() ?? string.Empty;
    [Parameter] public Func<TItem, string> ItemIconSelector { get; set; }
    [Parameter] public RenderFragment<TItem> ItemTemplate { get; set; }
    [Parameter] public RenderFragment EmptyTemplate { get; set; }
    [Parameter] public int MinSearchLength { get; set; } = 1;
    [Parameter] public int DebounceDelay { get; set; } = 300;
    [Parameter] public int MaxSuggestions { get; set; } = 10;
    [Parameter] public bool ShowLoading { get; set; } = true;
    [Parameter] public bool ClearOnSelect { get; set; }
    [Parameter] public bool OpenOnFocus { get; set; }
    [Parameter] public bool OpenOnClick { get; set; } = true;
    [Parameter] public bool ShowAllOnFocus { get; set; }
    [Parameter] public int MaxItemsToShow { get; set; } = 100;
    [Parameter] public bool EnableVirtualization { get; set; } = true;
    [Parameter] public FieldType InputType { get; set; } = FieldType.Text;
    [Parameter] public string Icon { get; set; }
    [Parameter] public bool ShowDropdownIcon { get; set; } = true;
    [Parameter] public EventCallback<TItem> OnItemSelected { get; set; }
    [Parameter] public EventCallback<string> OnSearchChanged { get; set; }
    [Parameter] public SizeType Size { get; set; } = SizeType.Medium;
    [Parameter] public bool ReadOnly { get; set; }
    [Parameter] public bool Required { get; set; }
    [Parameter] public string StartIcon { get; set; }
    [Parameter] public string EndIcon { get; set; }
    [Parameter] public string Placeholder { get; set; }
    [Parameter] public string Label { get; set; }
    [Parameter] public string HelpText { get; set; }

    private string SearchQuery
    {
        get => searchQuery;
        set => searchQuery = value;
    }

    private bool IsLoading => isLoading;
    private IEnumerable<TItem> FilteredItems => Items ?? Enumerable.Empty<TItem>();

    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (Value != null)
        {
            searchQuery = GetItemText(Value);
        }
        dotNetRef = DotNetObjectReference.Create(this);
    }

    protected override async Task InitializeJavaScriptAsync()
    {
        await base.InitializeJavaScriptAsync();

        if (autosuggestModule == null)
        {
            try
            {
                autosuggestModule = await ImportModuleAsync("./_content/RR.Blazor/js/autosuggest.js");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load autosuggest module: {ex.Message}");
            }
        }
    }

    private async Task OpenDropdown()
    {
        if (isDropdownOpen || autosuggestModule == null) return;
        
        isDropdownOpen = true;
        await InvokeAsync(StateHasChanged);
        await Task.Yield();
        
        var options = new
        {
            placement = "bottom-start",
            offset = 4,
            flip = true,
            constrain = true
        };

        try
        {
            await autosuggestModule.InvokeVoidAsync("open", autosuggestId, options);
        }
        catch (JSException jsEx)
        {
            var opened = await TryFallbackOpenAsync(options);
            if (!opened)
            {
                Console.WriteLine($"Failed to open dropdown: {jsEx.Message}");
                isDropdownOpen = false;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to open dropdown: {ex.Message}");
            isDropdownOpen = false;
        }
    }

    private async Task CloseDropdown()
    {
        if (!isDropdownOpen) return;
        
        isDropdownOpen = false;
        await TryCloseModuleAsync();
        StateHasChanged();
    }

    private async Task<bool> TryFallbackOpenAsync(object options)
    {
        if (autosuggestModule != null)
        {
            try
            {
                await autosuggestModule.InvokeVoidAsync("createPortal", autosuggestId, options);
                return true;
            }
            catch (Exception moduleFallbackEx)
            {
                Console.WriteLine($"Module fallback createPortal failed: {moduleFallbackEx.Message}");
            }
        }

        try
        {
            await SafeInvokeAsync("RRBlazor.Autosuggest.open", autosuggestId, options);
            return true;
        }
        catch (Exception globalFallbackEx)
        {
            Console.WriteLine($"Global autosuggest open failed: {globalFallbackEx.Message}");
            return false;
        }
    }

    private async Task TryCloseModuleAsync()
    {
        if (autosuggestModule != null)
        {
            try
            {
                await autosuggestModule.InvokeVoidAsync("close", autosuggestId);
                return;
            }
            catch (Exception moduleCloseEx)
            {
                Console.WriteLine($"Module close failed: {moduleCloseEx.Message}");
            }
        }

        await TryFallbackCloseAsync();
    }

    private async Task<bool> TryFallbackCloseAsync()
    {
        if (autosuggestModule != null)
        {
            try
            {
                await autosuggestModule.InvokeVoidAsync("closeDropdown", autosuggestId);
                return true;
            }
            catch (Exception moduleFallbackEx)
            {
                Console.WriteLine($"Module fallback closeDropdown failed: {moduleFallbackEx.Message}");
            }
        }

        try
        {
            await SafeInvokeAsync("RRBlazor.Autosuggest.close", autosuggestId);
            return true;
        }
        catch (Exception globalFallbackEx)
        {
            Console.WriteLine($"Global autosuggest close failed: {globalFallbackEx.Message}");
            return false;
        }
    }

    private async Task HandleValueChanged(string value)
    {
        if (searchQuery == value) return;
        
        searchQuery = value;
        await OnSearchChanged.InvokeAsync(value);
        await HandleSearch();
    }

    private async Task HandleInputFocus()
    {
        if (OpenOnFocus && !isDropdownOpen)
        {
            if (!string.IsNullOrWhiteSpace(searchQuery))
            {
                // If we have a search query, trigger search which will open dropdown if results exist
                await HandleSearch();
            }
            else if (ShowAllOnFocus && Items != null && Items.Any())
            {
                // Show all items if configured and we have items
                await OpenDropdown();
            }
        }
    }

    private async Task HandleInputBlur()
    {
        // Delay close to allow item clicks, but let click-outside handle the animation
        await Task.Delay(150);
        if (isDropdownOpen) 
        {
            // Use animated close for blur as well
            await CloseDropdownAnimated();
        }
    }
    
    private async Task CloseDropdownAnimated()
    {
        if (!isDropdownOpen) return;
        
        isDropdownOpen = false;
        
        await TryFallbackCloseAsync();
        
        StateHasChanged();
    }

    private async Task HandleInputClick(MouseEventArgs _)
    {
        if (!OpenOnClick || Disabled || ReadOnly) return;
        
        if (!isDropdownOpen)
        {
            // If we have items already (static list or previous search), show them
            if (FilteredItems.Any())
            {
                await OpenDropdown();
                selectedIndex = -1;
            }
            // If we have a search query, trigger search
            else if (!string.IsNullOrWhiteSpace(searchQuery) && SearchFunc != null)
            {
                await HandleSearch();
            }
            // If we have SearchFunc, trigger search with empty/minimal query to show initial results
            else if (SearchFunc != null)
            {
                // For SearchFunc, trigger search with minimal query to get suggestions
                var originalQuery = searchQuery;
                if (string.IsNullOrWhiteSpace(searchQuery))
                {
                    // Try empty query first - many search functions return popular/recent items
                    searchQuery = "";
                    await HandleSearch(bypassMinLength: true);
                    // Restore original query if search didn't yield results and we had something
                    if (!FilteredItems.Any() && !string.IsNullOrEmpty(originalQuery))
                    {
                        searchQuery = originalQuery;
                    }
                }
                else
                {
                    await HandleSearch();
                }
            }
            // If we have static Items, show them
            else if (Items != null && Items.Any())
            {
                await OpenDropdown();
                selectedIndex = -1;
            }
        }
    }

    private async Task HandleSearch(bool bypassMinLength = false)
    {
        cancellationTokenSource?.Cancel();
        debounceTimer?.Dispose();

        if (!bypassMinLength && (string.IsNullOrWhiteSpace(searchQuery) || searchQuery.Length < MinSearchLength))
        {
            await CloseDropdown();
            return;
        }

        searchGeneration++;
        var currentGeneration = searchGeneration;

        cancellationTokenSource = new CancellationTokenSource();
        debounceTimer = new Timer(async _ =>
        {
            await InvokeAsync(async () =>
            {
                if (SearchFunc == null || currentGeneration != searchGeneration) return;

                try
                {
                    var openedForSearch = false;

                    if (!isDropdownOpen)
                    {
                        selectedIndex = -1;
                        await OpenDropdown();
                        openedForSearch = true;
                    }

                    if (ShowLoading)
                    {
                        isLoading = true;
                        if (!openedForSearch)
                        {
                            StateHasChanged();
                        }
                    }
                    
                    var results = await SearchFunc(searchQuery, cancellationTokenSource.Token);
                    if (currentGeneration == searchGeneration)
                    {
                        Items = results ?? Enumerable.Empty<TItem>();
                        isLoading = false;
                        selectedIndex = -1;

                        if (!isDropdownOpen)
                        {
                            await OpenDropdown();
                        }

                        StateHasChanged();
                    }
                }
                catch (OperationCanceledException) 
                { 
                    if (currentGeneration == searchGeneration)
                    {
                        isLoading = false;
                        if (isDropdownOpen && ShowLoading)
                        {
                            StateHasChanged();
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Search error: {ex.Message}");
                    if (currentGeneration == searchGeneration)
                    {
                        isLoading = false;
                        if (isDropdownOpen)
                        {
                            StateHasChanged();
                        }
                    }
                }
            });
        }, null, DebounceDelay, Timeout.Infinite);
    }

    private async Task HandleItemSelect(TItem item)
    {
        Value = item;
        searchQuery = ClearOnSelect ? string.Empty : GetItemText(item);
        await CloseDropdown();
        await ValueChanged.InvokeAsync(item);
        await OnItemSelected.InvokeAsync(item);
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (!isDropdownOpen || !FilteredItems.Any()) return;

        switch (e.Key)
        {
            case "ArrowDown":
                selectedIndex = Math.Min(selectedIndex + 1, FilteredItems.Count() - 1);
                break;

            case "ArrowUp":
                selectedIndex = Math.Max(selectedIndex - 1, -1);
                break;

            case "Enter":
                if (selectedIndex >= 0 && selectedIndex < FilteredItems.Count())
                {
                    await HandleItemSelect(FilteredItems.ElementAt(selectedIndex));
                }
                break;

            case "Escape":
                await CloseDropdown();
                break;
        }
    }

    private void SetSelectedIndex(int index)
    {
        selectedIndex = index;
    }

    private string GetItemText(TItem item) => ItemTextSelector?.Invoke(item) ?? item?.ToString() ?? string.Empty;
    private string GetItemIcon(TItem item) => ItemIconSelector?.Invoke(item) ?? string.Empty;

    private string GetEffectiveStartIcon()
    {
        return !string.IsNullOrEmpty(StartIcon) ? StartIcon : Icon;
    }

    private string GetEndIcon()
    {
        // Never change icon during loading to prevent jumping
        if (!string.IsNullOrEmpty(EndIcon)) return EndIcon;
        // Always show consistent icon to prevent layout shifts
        return ShowDropdownIcon ? (isDropdownOpen ? "expand_less" : "expand_more") : string.Empty;
    }

    private string GetAutosuggestClasses()
    {
        var classes = new List<string> { GetBaseClasses() };
        
        if (isDropdownOpen) classes.Add("autosuggest-open");
        // Don't add loading class to root element to prevent layout shifts
        if (Disabled) classes.Add("autosuggest-disabled");
        
        return string.Join(" ", classes);
    }

    private string GetTriggerContainerClasses() => "autosuggest-input";

    private string GetTriggerInputClasses() => "autosuggest-trigger";

    private Dictionary<string, object> GetTriggerAttributes()
    {
        return new Dictionary<string, object>
        {
            ["data-autosuggest-trigger"] = "true",
            ["role"] = "combobox",
            ["aria-autocomplete"] = "list",
            ["aria-expanded"] = isDropdownOpen ? "true" : "false"
        };
    }

    private string GetItemClasses(int index)
    {
        var classes = new List<string> { "autosuggest-item" };
        if (index == selectedIndex) classes.Add("selected");
        return string.Join(" ", classes);
    }


    protected override async ValueTask DisposeAsyncCore()
    {
        debounceTimer?.Dispose();
        cancellationTokenSource?.Cancel();
        cancellationTokenSource?.Dispose();
        
        if (isDropdownOpen)
        {
            await CloseDropdown();
        }
        
        if (autosuggestModule != null)
        {
            await autosuggestModule.DisposeAsync();
        }
        
        dotNetRef?.Dispose();
    }
}
