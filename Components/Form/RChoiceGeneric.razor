@**
<summary>Universal choice system - adapts between inline and dropdown modes</summary>
<category>Form</category>
**@

@attribute [Component("RChoiceGeneric", Category = "Form")]
@attribute [AIOptimized(Prompt = "Create adaptive choice component")]

@typeparam TValue where TValue : notnull
@inherits RChoiceBase
@using Microsoft.AspNetCore.Components
@using RR.Blazor.Components.Form
@using RR.Blazor.Enums
@using RR.Blazor.Models
@using RR.Blazor.Services
@using RR.Blazor.Utilities
@using static RR.Blazor.Enums.ChoiceVariant
@using static RR.Blazor.Enums.ChoiceType
@using static RR.Blazor.Enums.ChoiceDirection
@using static RR.Blazor.Enums.ChoiceSelectionMode
@implements IAsyncDisposable

<div class="@GetComponentClasses()">
    @if (!string.IsNullOrEmpty(Label))
    {
        <label class="@GetLabelClasses()">@Label</label>
    }
    
    @if (HasSearchBox)
    {
        <div class="choice-search">
            <div class="choice-search-wrapper">
                <i class="icon choice-search-icon">search</i>
                <input class="choice-search-input" 
                       type="text" 
                       placeholder="@(SearchPlaceholder ?? "Search options...")"
                       value="@SearchTerm"
                       @oninput="OnSearchInput" />
                @if (!string.IsNullOrEmpty(SearchTerm))
                {
                    <button class="choice-search-clear" type="button" @onclick="ClearSearch">
                        <i class="icon">close</i>
                    </button>
                }
            </div>
        </div>
    }
    
    @if (EffectiveVariant == Grouped && GroupedItems.Any())
    {
        <div class="choice-grouped @GetGroupedClasses()">
            @foreach (var group in GetVisibleGroups())
            {
                <RChoiceGroup Group="group" 
                             GroupStyle="@GroupStyle" 
                             Size="@Size" 
                             Density="@Density"
                             SelectionMode="@SelectionMode"
                             ShowHeader="true"
                             ShowExpandIcon="true"
                             ShowAlternatingRows="@ShowAlternatingRows"
                             SearchTerm="@SearchTerm"
                             SelectedItemIds="@SelectedItemIds"
                             ItemTemplate="@GroupItemTemplate"
                             OnItemSelected="OnGroupItemSelected"
                             OnGroupToggled="OnGroupToggled" />
            }
        </div>
    }
    else if (EffectiveVariant == Tree && TreeItems.Any())
    {
        <div class="choice-tree @GetTreeClasses()">
            <RChoiceTree Items="@GetVisibleTreeItems()" 
                        TreeStyle="@TreeStyle" 
                        Size="@Size" 
                        Density="@Density"
                        SelectionMode="@SelectionMode"
                        ShowExpandIcon="true"
                        ShowConnectingLines="@ShowTreeLines"
                        EnableCascadeSelection="@EnableCascadeSelection"
                        ShowAlternatingRows="@ShowAlternatingRows"
                        SearchTerm="@SearchTerm"
                        SelectedItemIds="@SelectedItemIds"
                        ExpandedItemIds="@ExpandedItemIds"
                        ItemTemplate="@TreeItemTemplate"
                        OnItemSelected="OnTreeItemSelected"
                        OnItemExpanded="HandleTreeItemExpanded"
                        OnItemCollapsed="HandleTreeItemCollapsed" />
        </div>
    }
    else if (EffectiveVariant == Dropdown || TriggerContent != null)
    {
        <div @ref="choiceElement" class="choice-dropdown relative @(TriggerContent != null ? "w-auto" : "") @(TriggerContent != null ? "" : GetDropdownDensityClass())" 
             data-choice-id="@choiceElementId">
        
            @if (TriggerContent != null)
            {
                <div class="choice-trigger-wrapper"
                     @onclick="ToggleDropdown"
                     @onclick:stopPropagation="true">
                    @TriggerContent
                </div>
            }
            else
            {
                <button class="choice-trigger w-full"
                        type="button"
                        aria-haspopup="true"
                        aria-expanded="false"
                        aria-label="@(AriaLabel ?? "Open dropdown")"
                        disabled="@Disabled"
                        @onclick="ToggleDropdown">
                    <div class="@GetTriggerClasses()">
                        @if (!string.IsNullOrEmpty(GetSelectedItemIcon()))
                        {
                            <i class="@GetIconClasses()">@GetSelectedItemIcon()</i>
                        }
                        <span class="@GetTextClasses()">@GetSelectedItemLabel()</span>
                    </div>
                </button>
            }
            
            @* Viewport as child - hidden but present in DOM *@
            <div class="choice-viewport choice-viewport-closed" @ref="viewportElement" data-viewport-id="@choiceElementId" style="position: absolute; top: -9999px; left: -9999px; visibility: hidden;">
            <div class="choice-content">
                @if (Items != null)
                {
                    @foreach (var item in Items)
                    {
                        @if (ItemTemplate != null)
                        {
                            @if (IsItemDivider(item))
                            {
                                @ItemTemplate(item)
                            }
                            else if (OnItemClick.HasDelegate)
                            {
                                <div class="choice-item @GetItemClass(item) cursor-pointer"
                                     data-value="@GetItemValue(item)"
                                     @onclick="() => OnItemSelected(item)"
                                     @onclick:stopPropagation="true">
                                    @ItemTemplate(item)
                                </div>
                            }
                            else
                            {
                                @* Don't wrap in button if no OnItemClick - let ItemTemplate handle its own clicks *@
                                @ItemTemplate(item)
                            }
                        }
                        else
                        {
                            <button class="choice-item @GetItemClass(item)"
                                    type="button"
                                    disabled="@IsItemDisabled(item)"
                                    title="@GetItemTitle(item)"
                                    aria-label="@GetItemAriaLabel(item)"
                                    data-value="@GetItemValue(item)"
                                    @onclick="() => OnItemSelected(item)">
                                @if (IsItemActive(item) && ShowActiveIndicator)
                                {
                                    <i class="@GetCheckIconClasses()">check</i>
                                }
                                else if (!string.IsNullOrEmpty(GetItemIcon(item)))
                                {
                                    <i class="@GetItemIconClasses()">@GetItemIcon(item)</i>
                                }
                                <span class="choice-text">@GetItemLabel(item)</span>
                            </button>
                        }
                    }
                }
            </div>
        </div>
        </div>
    }
    else
    {
        <div class="@GetInlineClass()">
            @if (Items != null)
            {
                @foreach (var item in Items)
                {
                    <button class="choice-item @GetItemClass(item)" 
                            type="button"
                            title="@GetItemTitle(item)"
                            aria-label="@GetItemAriaLabel(item)"
                            disabled="@IsItemDisabled(item)"
                            @onclick="() => OnItemSelected(item)">
                        @if (!string.IsNullOrEmpty(GetItemIcon(item)))
                        {
                            <i class="@GetItemIconClasses()">@GetItemIcon(item)</i>
                        }
                        @if (ShowLabels && !string.IsNullOrEmpty(GetItemLabel(item)))
                        {
                            <span class="choice-label">@GetItemLabel(item)</span>
                        }
                        @if (IsItemActive(item) && ShowActiveIndicator)
                        {
                            <i class="@GetCheckIconClasses()">check</i>
                        }
                        @if (IsItemLoading(item))
                        {
                            <div class="choice-loading">
                                <i class="@GetLoadingIconClasses()">hourglass_empty</i>
                            </div>
                        }
                    </button>
                }
            }
        </div>
    }
    
    @if (HasError && !string.IsNullOrEmpty(ErrorMessage))
    {
        <div class="@GetErrorMessageClasses()">
            <i class="@GetErrorIconClasses()">error</i>
            @ErrorMessage
        </div>
    }
    
    @if (!string.IsNullOrEmpty(HelpText))
    {
        <div class="@GetHelpTextClasses()">@HelpText</div>
    }
</div>

@inject IJSRuntime JS

@code {
    private ElementReference choiceElement;
    private ElementReference viewportElement;
    private string choiceElementId = Guid.NewGuid().ToString("N")[..8];
    private bool disposed = false;

    [Parameter] public IEnumerable<TValue> Items { get; set; }
    [Parameter] public TValue SelectedValue { get; set; }
    [Parameter] public EventCallback<TValue> SelectedValueChangedTyped { get; set; }
    [Parameter] public EventCallback<object> SelectedValueChangedObject { get; set; }
    [Parameter] public Func<TValue, string> ItemLabelSelectorTyped { get; set; }
    [Parameter] public Func<TValue, string> ItemIconSelectorTyped { get; set; }
    [Parameter] public Func<TValue, string> ItemTitleSelectorTyped { get; set; }
    [Parameter] public Func<TValue, string> ItemAriaLabelSelectorTyped { get; set; }
    [Parameter] public Func<TValue, bool> ItemDisabledSelectorTyped { get; set; }
    [Parameter] public Func<TValue, bool> ItemLoadingSelectorTyped { get; set; }
    [Parameter] public ChoiceVariant EffectiveVariant { get; set; } = Inline;
    [Parameter] public RenderFragment TriggerContent { get; set; }
    [Parameter] public RenderFragment<object> ItemTemplate { get; set; }
    [Parameter] public EventCallback<TValue> OnItemClick { get; set; }
    [Parameter] public DropdownDirection DropdownDirection { get; set; } = DropdownDirection.Auto;
    
    [Parameter] public bool UseBackdrop { get; set; } = false;
    [Parameter] public string BackdropClass { get; set; } = "";
    [Parameter] public bool CloseOnBackdropClick { get; set; } = true;
    [Parameter] public bool CloseOnEscape { get; set; } = true;
    [Parameter] public bool EnableVirtualScrolling { get; set; } = true;
    
    // Group and Tree Parameters
    [Parameter] public IEnumerable<IChoiceGroup> GroupedItems { get; set; } = Enumerable.Empty<IChoiceGroup>();
    [Parameter] public IEnumerable<IChoiceTreeItem> TreeItems { get; set; } = Enumerable.Empty<IChoiceTreeItem>();
    [Parameter] public ChoiceSelectionMode SelectionMode { get; set; } = ChoiceSelectionMode.Single;
    [Parameter] public ChoiceGroupStyle GroupStyle { get; set; } = ChoiceGroupStyle.Header;
    [Parameter] public ChoiceTreeStyle TreeStyle { get; set; } = ChoiceTreeStyle.Standard;
    [Parameter] public bool ShowAlternatingRows { get; set; } = true;
    [Parameter] public bool ShowTreeLines { get; set; } = false;
    [Parameter] public bool EnableCascadeSelection { get; set; } = true;
    
    // Search Parameters
    [Parameter] public bool HasSearchBox { get; set; } = false;
    [Parameter] public string SearchTerm { get; set; } = "";
    [Parameter] public string SearchPlaceholder { get; set; } = "";
    [Parameter] public EventCallback<string> SearchTermChanged { get; set; }
    
    // Template Parameters
    [Parameter] public RenderFragment<IChoiceItem> GroupItemTemplate { get; set; }
    [Parameter] public RenderFragment<IChoiceTreeItem> TreeItemTemplate { get; set; }
    
    // Selection State
    [Parameter] public HashSet<string> SelectedItemIds { get; set; } = new();
    [Parameter] public HashSet<string> ExpandedItemIds { get; set; } = new();
    
    // Events
    [Parameter] public EventCallback<IChoiceGroup> OnGroupToggled { get; set; }
    [Parameter] public EventCallback<IChoiceTreeItem> OnTreeItemExpanded { get; set; }
    [Parameter] public EventCallback<IChoiceTreeItem> OnTreeItemCollapsed { get; set; }

    protected override bool ShouldRender() => true;

    private string GetInlineClass()
    {
        var styleClass = GetStyleClass();
        var densityClass = DensityHelper.GetGap(Density);
        var directionClass = Direction == Vertical ? " choice-vertical flex-col" : "";
        
        return $"choice-inline {styleClass} {densityClass}{directionClass}";
    }
    
    private string GetStyleClass() => Type switch
    {
        ChoiceType.Pills => "choice-pills d-flex",
        ChoiceType.Tabs => "choice-tabs d-flex border-b border-light", 
        ChoiceType.Buttons => "choice-buttons d-flex",
        ChoiceType.Compact => "choice-compact d-flex",
        _ => "choice-switcher d-flex p-1 bg-surface rounded-lg"
    };
    
    private string GetDensityClass() => Density switch
    {
        DensityType.Compact => "choice-compact",
        DensityType.Dense => "choice-dense", 
        DensityType.Spacious => "choice-spacious",
        _ => "choice-normal"
    };

    private string GetDropdownDensityClass() => 
        $"{GetDensityClass()} {DensityHelper.GetInputDensityClasses(Density)}";

    private string GetItemClass(TValue item)
    {
        var baseClasses = new List<string>
        {
            "choice-item",
            GetTextSizeClasses(),
            DensityHelper.GetInputDensityClasses(Density)
        };
        
        if (IsItemDisabled(item)) baseClasses.Add("choice-item-disabled");
        if (IsItemLoading(item)) baseClasses.Add("choice-item-loading");
        if (IsItemActive(item)) baseClasses.Add("choice-item-active");
        
        return string.Join(" ", baseClasses);
    }

    /// <summary>
    /// Gets the main component wrapper classes using design system patterns
    /// </summary>
    private string GetComponentClasses()
    {
        var classes = new List<string>();
        
        // Use %component-foundation pattern
        var needsFormWrapper = !string.IsNullOrEmpty(Label) || !string.IsNullOrEmpty(ErrorMessage) || HasError;
        if (needsFormWrapper) classes.Add("form-wrapper");
        
        classes.Add(GetBaseClasses());
        classes.Add(GetSizeClassesWithDensity());
        
        if (HasError) classes.Add("choice-error form-error");
        if (Disabled) classes.Add("choice-disabled");
        
        return string.Join(" ", classes.Where(c => !string.IsNullOrEmpty(c)));
    }
    
    private string GetLabelClasses() => 
        $"choice-label form-label {GetTextSizeClasses()} font-medium text-muted mb-2" + (Required ? " choice-label-required form-label-required" : "");
    
    private string GetErrorMessageClasses() => 
        $"choice-error-message form-error text-error {GetTextSizeClasses()} mt-1 d-flex align-center {DensityHelper.GetGap(Density)}";
        
    private string GetHelpTextClasses() => 
        $"choice-help-text form-help text-muted {GetTextSizeClasses()} mt-1";
    
    #region New Semantic CSS Class Methods
    
    /// <summary>
    /// Gets trigger content wrapper classes using design system patterns
    /// </summary>
    private string GetTriggerContentClasses() =>
        $"d-flex align-center justify-between w-full {DensityHelper.GetGap(Density)}";
    
    /// <summary>
    /// Gets trigger classes using design system patterns
    /// </summary>
    private string GetTriggerClasses() =>
        $"d-flex align-center {DensityHelper.GetGap(Density)}";
    
    /// <summary>
    /// Gets icon classes using design system patterns  
    /// </summary>
    private string GetItemIconClasses() =>
        $"icon choice-icon {GetIconSizeClasses()}";
    
    /// <summary>
    /// Gets check icon classes using design system patterns
    /// </summary>
    private string GetCheckIconClasses() =>
        $"icon choice-check {GetIconSizeClasses()}";
    
    /// <summary>
    /// Gets loading icon classes using design system patterns
    /// </summary>
    private string GetLoadingIconClasses() =>
        $"icon animate-spin {GetIconSizeClasses()}";
    
    /// <summary>
    /// Gets error icon classes using design system patterns
    /// </summary>
    private string GetErrorIconClasses() =>
        $"icon text-error mr-1 {GetIconSizeClasses()}";
    
    #endregion

    private bool IsItemActive(TValue item) => EqualityComparer<TValue>.Default.Equals(item, SelectedValue);
    private bool IsItemDisabled(TValue item) => ItemDisabledSelectorTyped?.Invoke(item) ?? false;
    private bool IsItemLoading(TValue item) => ItemLoadingSelectorTyped?.Invoke(item) ?? false;
    private bool IsItemDivider(TValue item) => item?.ToString()?.StartsWith("divider") ?? false;

    private string GetItemLabel(TValue item) => ItemLabelSelectorTyped?.Invoke(item) ?? item.ToString();
    private string GetItemIcon(TValue item) => ItemIconSelectorTyped?.Invoke(item) ?? "";
    private string GetItemTitle(TValue item) => ItemTitleSelectorTyped?.Invoke(item) ?? GetItemLabel(item);
    private string GetItemAriaLabel(TValue item) => ItemAriaLabelSelectorTyped?.Invoke(item) ?? $"Select {GetItemLabel(item)}";
    private string GetItemValue(TValue item) => item.ToString();

    private string GetSelectedItemLabel() => 
        SelectedValue != null ? GetItemLabel(SelectedValue) : "Select an option";

    private string GetSelectedItemIcon() => 
        SelectedValue != null ? GetItemIcon(SelectedValue) : "";

    private async Task ToggleDropdown() 
    {
        if (Disabled) return;
        
        await SafeInvokeAsync("RRBlazor.Choice.toggleDropdown", choiceElementId, new {
            direction = DropdownDirection.ToString().ToLowerInvariant(),
            useBackdrop = UseBackdrop,
            backdropClass = BackdropClass,
            closeOnBackdropClick = CloseOnBackdropClick,
            closeOnEscape = CloseOnEscape
        });
    }
    
    private async Task OpenDropdown() 
    {
        if (Disabled) return;
        
        StateHasChanged();
        await Task.Yield();
        
        await SafeInvokeAsync("RRBlazor.Choice.openDropdown", choiceElementId, new {
            direction = DropdownDirection.ToString().ToLowerInvariant(),
            useBackdrop = UseBackdrop,
            backdropClass = BackdropClass,
            closeOnBackdropClick = CloseOnBackdropClick,
            closeOnEscape = CloseOnEscape
        });
    }
    
    private async Task CloseDropdown() => await SafeInvokeAsync("RRBlazor.Choice.closeDropdown", choiceElementId);

    private async Task OnItemSelected(TValue item)
    {
        if (IsItemDisabled(item) || IsItemLoading(item)) return;

        if (OnItemClick.HasDelegate) await OnItemClick.InvokeAsync(item);

        SelectedValue = item;
        
        if (SelectedValueChangedTyped.HasDelegate) await SelectedValueChangedTyped.InvokeAsync(item);
        if (SelectedValueChangedObject.HasDelegate) await SelectedValueChangedObject.InvokeAsync(item);
        
        if (EffectiveVariant == Dropdown && CloseOnSelect) 
            await SafeInvokeAsync("RRBlazor.Choice.closeDropdown", choiceElementId);
    }
    
    #region Group and Tree Support Methods
    
    private string GetGroupedClasses()
    {
        var classes = new List<string>
        {
            $"choice-grouped-{GroupStyle.ToString().ToLowerInvariant()}",
            DensityHelper.GetInputDensityClasses(Density)
        };
        
        if (HasSearchBox) classes.Add("choice-grouped-searchable");
        if (ShowAlternatingRows) classes.Add("choice-grouped-striped");
        
        return string.Join(" ", classes);
    }
    
    private string GetTreeClasses()
    {
        var classes = new List<string>
        {
            $"choice-tree-{TreeStyle.ToString().ToLowerInvariant()}",
            DensityHelper.GetInputDensityClasses(Density)
        };
        
        if (HasSearchBox) classes.Add("choice-tree-searchable");
        if (ShowTreeLines) classes.Add("choice-tree-lines");
        if (EnableCascadeSelection) classes.Add("choice-tree-cascade");
        if (ShowAlternatingRows) classes.Add("choice-tree-striped");
        
        return string.Join(" ", classes);
    }
    
    private IEnumerable<IChoiceGroup> GetVisibleGroups()
    {
        var groups = GroupedItems;
        
        if (!string.IsNullOrEmpty(SearchTerm))
        {
            groups = groups.Where(g => 
                g.Label.Contains(SearchTerm, StringComparison.OrdinalIgnoreCase) ||
                g.Items.Any(i => i.Label.Contains(SearchTerm, StringComparison.OrdinalIgnoreCase)));
        }
        
        return groups;
    }
    
    private IEnumerable<IChoiceTreeItem> GetVisibleTreeItems()
    {
        var items = TreeItems;
        
        if (!string.IsNullOrEmpty(SearchTerm))
        {
            return FilterTreeItemsBySearch(items).ToList();
        }
        
        return items;
    }
    
    private IEnumerable<IChoiceTreeItem> FilterTreeItemsBySearch(IEnumerable<IChoiceTreeItem> items)
    {
        foreach (var item in items)
        {
            var matches = item.Label.Contains(SearchTerm, StringComparison.OrdinalIgnoreCase) ||
                         (!string.IsNullOrEmpty(item.Description) && item.Description.Contains(SearchTerm, StringComparison.OrdinalIgnoreCase));
            
            var hasMatchingChildren = item.Children.Any() && FilterTreeItemsBySearch(item.Children).Any();
            
            if (matches || hasMatchingChildren)
            {
                // Expand nodes with matching descendants for better UX
                if (hasMatchingChildren && !ExpandedItemIds.Contains(item.Id))
                {
                    ExpandedItemIds.Add(item.Id);
                    item.IsExpanded = true;
                }
                
                yield return item;
            }
        }
    }
    
    private async Task OnSearchInput(ChangeEventArgs e)
    {
        SearchTerm = e.Value?.ToString() ?? "";
        if (SearchTermChanged.HasDelegate)
        {
            await SearchTermChanged.InvokeAsync(SearchTerm);
        }
        StateHasChanged();
    }
    
    private async Task ClearSearch()
    {
        SearchTerm = "";
        if (SearchTermChanged.HasDelegate)
        {
            await SearchTermChanged.InvokeAsync(SearchTerm);
        }
        StateHasChanged();
    }
    
    private async Task OnGroupItemSelected(IChoiceItem item)
    {
        if (SelectionMode == ChoiceSelectionMode.Single)
        {
            SelectedItemIds.Clear();
        }
        
        if (SelectedItemIds.Contains(item.Id))
        {
            SelectedItemIds.Remove(item.Id);
        }
        else
        {
            SelectedItemIds.Add(item.Id);
        }
        
        // Convert to TValue if possible for compatibility
        if (item.Value is TValue typedValue)
        {
            SelectedValue = typedValue;
            if (SelectedValueChangedTyped.HasDelegate) await SelectedValueChangedTyped.InvokeAsync(typedValue);
            if (SelectedValueChangedObject.HasDelegate) await SelectedValueChangedObject.InvokeAsync(typedValue);
        }
        
        StateHasChanged();
    }
    
    private async Task OnTreeItemSelected(IChoiceTreeItem item)
    {
        if (SelectionMode == ChoiceSelectionMode.Single)
        {
            SelectedItemIds.Clear();
        }
        
        if (SelectedItemIds.Contains(item.Id))
        {
            SelectedItemIds.Remove(item.Id);
        }
        else
        {
            SelectedItemIds.Add(item.Id);
        }
        
        // Convert to TValue if possible for compatibility
        if (item.Value is TValue typedValue)
        {
            SelectedValue = typedValue;
            if (SelectedValueChangedTyped.HasDelegate) await SelectedValueChangedTyped.InvokeAsync(typedValue);
            if (SelectedValueChangedObject.HasDelegate) await SelectedValueChangedObject.InvokeAsync(typedValue);
        }
        
        StateHasChanged();
    }
    
    private async Task HandleTreeItemExpanded(IChoiceTreeItem item)
    {
        ExpandedItemIds.Add(item.Id);
        if (OnTreeItemExpanded.HasDelegate)
        {
            await OnTreeItemExpanded.InvokeAsync(item);
        }
    }
    
    private async Task HandleTreeItemCollapsed(IChoiceTreeItem item)
    {
        ExpandedItemIds.Remove(item.Id);
        if (OnTreeItemCollapsed.HasDelegate)
        {
            await OnTreeItemCollapsed.InvokeAsync(item);
        }
    }
    
    #endregion
    
    public new async ValueTask DisposeAsync()
    {
        if (disposed) return;
        disposed = true;
        
        await SafeInvokeAsync("RRBlazor.Choice.closeDropdown", choiceElementId);
        await base.DisposeAsync();
    }
}