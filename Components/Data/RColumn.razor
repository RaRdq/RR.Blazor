@using RR.Blazor.Models
@using System.Linq.Expressions
@using System.Reflection
@inherits RColumnBase

@code {
    [CascadingParameter] public ITableParent ParentTable { get; set; }
    [CascadingParameter] public TableContext TableContext { get; set; }
    
    [Parameter] public object For { get; set; }
    [Parameter] public string Property { get; set; }
    [Parameter] public RenderFragment ChildContent { get; set; }
    [Parameter] public RenderFragment<object> CellTemplate { get; set; }
    
    protected override void OnInitialized()
    {
        if (ParentTable != null && TableContext?.ItemType != null)
        {
            var columnDef = CreateColumnDefinition();
            if (columnDef != null)
            {
                ParentTable.AddColumn(columnDef);
            }
        }
        
        base.OnInitialized();
    }
    
    private object CreateColumnDefinition()
    {
        var itemType = TableContext.ItemType;
        
        if (!string.IsNullOrEmpty(Property))
        {
            return CreateColumnFromProperty(Property);
        }
        
        if (For != null)
        {
            return CreateColumnFromLambda(For);
        }
        
        throw new InvalidOperationException("Column must specify either Property or For parameter");
    }
    
    private object CreateColumnFromProperty(string propertyName)
    {
        var itemType = TableContext.ItemType;
        var propertyInfo = itemType.GetProperty(propertyName);
        
        var parameter = Expression.Parameter(itemType, "x");
        var propertyAccess = Expression.Property(parameter, propertyInfo);
        var converted = propertyInfo.PropertyType != typeof(object) 
            ? Expression.Convert(propertyAccess, typeof(object))
            : (Expression)propertyAccess;
            
        var funcType = typeof(Func<,>).MakeGenericType(itemType, typeof(object));
        var lambda = Expression.Lambda(funcType, converted, parameter);
        
        return CreateColumnDefinition(itemType, lambda, propertyName);
    }
    
    private object CreateColumnFromLambda(object lambda)
    {
        var itemType = TableContext.ItemType;
        var lambdaExpr = (LambdaExpression)lambda;
        var propertyName = GetPropertyNameFromLambda(lambdaExpr);
        var convertedLambda = ConvertLambdaExpression(lambdaExpr, itemType);
        
        return CreateColumnDefinition(itemType, convertedLambda, propertyName);
    }
    
    private object CreateColumnDefinition(Type itemType, object typedLambda, string propertyName)
    {
        var columnDefType = typeof(ColumnDefinition<>).MakeGenericType(itemType);
        var columnDef = Activator.CreateInstance(columnDefType);
        
        SetProperty(columnDef, "Property", typedLambda);
        SetProperty(columnDef, "CompiledProperty", CompileExpression(typedLambda));
        SetProperty(columnDef, "Title", Header ?? Title ?? propertyName);
        SetProperty(columnDef, "Key", propertyName);
        SetProperty(columnDef, "Sortable", Sortable ?? true); // Default: sortable
        SetProperty(columnDef, "Searchable", Searchable ?? true); // Default: searchable
        SetProperty(columnDef, "Width", Width);
        SetProperty(columnDef, "Format", Format);
        SetProperty(columnDef, "EmptyText", EmptyText ?? "-");
        SetProperty(columnDef, "Order", Order);
        SetProperty(columnDef, "Visible", Visible);
        
        // Handle custom template - prioritize CellTemplate parameter, then ChildContent
        RenderFragment<object> templateToUse = null;
        if (CellTemplate != null)
        {
            // Direct CellTemplate parameter (for programmatic use)
            templateToUse = CellTemplate;
        }
        else if (ChildContent != null)
        {
            // ChildContent might contain a CellTemplate component or direct content
            // We'll treat it as a template either way
            templateToUse = context => ChildContent;
        }
        
        if (templateToUse != null)
        {
            // Create a typed RenderFragment<TItem> from the template
            var typedTemplate = CreateTypedTemplate(itemType, templateToUse);
            SetProperty(columnDef, "CustomTemplate", typedTemplate);
        }
        
        return columnDef;
    }
    
    private string GetPropertyNameFromLambda(LambdaExpression lambda)
    {
        return lambda.Body switch
        {
            MemberExpression member => member.Member.Name,
            UnaryExpression { Operand: MemberExpression member } => member.Member.Name,
            _ => ""
        };
    }
    
    private void SetProperty(object obj, string propertyName, object value)
    {
        var property = obj.GetType().GetProperty(propertyName);
        property.SetValue(obj, value);
    }
    
    private object CreateTypedTemplate(Type itemType, RenderFragment<object> template)
    {
        // Use reflection to create a typed RenderFragment<TItem> from RenderFragment<object>
        var renderMethod = typeof(RColumn).GetMethod(nameof(CreateRenderFragment), BindingFlags.NonPublic | BindingFlags.Static);
        var genericMethod = renderMethod.MakeGenericMethod(itemType);
        return genericMethod.Invoke(null, new object[] { template });
    }
    
    private static RenderFragment<TItem> CreateRenderFragment<TItem>(RenderFragment<object> template) where TItem : class
    {
        // Convert RenderFragment<object> to RenderFragment<TItem>
        // The template expects 'context' as the parameter name, which is the default
        return (TItem item) => template(item);
    }
    
    private object ConvertLambdaExpression(object lambda, Type itemType)
    {
        var lambdaExpr = (LambdaExpression)lambda;
        var funcType = typeof(Func<,>).MakeGenericType(itemType, typeof(object));
        
        var parameter = lambdaExpr.Parameters[0];
        var body = lambdaExpr.Body;
        
        if (body.Type != typeof(object) && body.Type.IsValueType)
        {
            body = Expression.Convert(body, typeof(object));
        }
        
        var newParameter = Expression.Parameter(itemType, parameter.Name);
        var visitor = new ParameterReplacerVisitor(parameter, newParameter);
        var newBody = visitor.Visit(body);
        
        return Expression.Lambda(funcType, newBody, newParameter);
    }
    
    private object CompileExpression(object expression)
    {
        var compileMethod = expression.GetType().GetMethod("Compile", Type.EmptyTypes);
        return compileMethod.Invoke(expression, null);
    }
    
    private string GetPropertyName()
    {
        // First try Property parameter (string-based, compile-time safe)
        if (!string.IsNullOrEmpty(Property))
            return Property;
            
        // Then try extracting from lambda expression (if it compiled successfully)
        if (For is LambdaExpression lambda)
        {
            return lambda.Body switch
            {
                MemberExpression member => member.Member.Name,
                UnaryExpression { Operand: MemberExpression member } => member.Member.Name,
                _ => ""
            };
        }
        return "";
    }
    
    private object CreateTypedExpressionFromProperty(string propertyName, Type itemType)
    {
        try
        {
            // Get the property info
            var propertyInfo = itemType.GetProperty(propertyName);
            if (propertyInfo == null)
                return null;
                
            // Create parameter: x => 
            var parameter = Expression.Parameter(itemType, "x");
            
            // Create property access: x.PropertyName
            var propertyAccess = Expression.Property(parameter, propertyInfo);
            
            // Convert to object if needed: (object)x.PropertyName
            var body = propertyInfo.PropertyType != typeof(object) 
                ? Expression.Convert(propertyAccess, typeof(object))
                : (Expression)propertyAccess;
                
            // Create the lambda: x => (object)x.PropertyName
            var funcType = typeof(Func<,>).MakeGenericType(itemType, typeof(object));
            var lambda = Expression.Lambda(funcType, body, parameter);
            
            return lambda;
        }
        catch
        {
            return null;
        }
    }
    
    private class ParameterReplacerVisitor : ExpressionVisitor
    {
        private readonly ParameterExpression _oldParameter;
        private readonly ParameterExpression _newParameter;
        
        public ParameterReplacerVisitor(ParameterExpression oldParameter, ParameterExpression newParameter)
        {
            _oldParameter = oldParameter;
            _newParameter = newParameter;
        }
        
        protected override Expression VisitParameter(ParameterExpression node)
        {
            return node == _oldParameter ? _newParameter : base.VisitParameter(node);
        }
    }
}