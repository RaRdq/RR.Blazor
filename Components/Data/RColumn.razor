@using RR.Blazor.Models
@using System.Linq.Expressions
@using System.Reflection
@using System
@inherits RColumnBase

@code {
    [CascadingParameter] public ITableParent ParentTable { get; set; }
    [CascadingParameter] public TableContext TableContext { get; set; }
    
    [Parameter] public object For { get; set; }
    [Parameter] public string Property { get; set; }
    // ChildContent inherited from RForwardingComponentBase
    [Parameter] public RenderFragment<object> CellTemplate { get; set; }
    
    protected override void OnInitialized()
    {
        // Validate required parameters - allow CellTemplate-only columns
        if (string.IsNullOrEmpty(Property) && For == null && CellTemplate == null && ChildContent == null)
        {
            throw new InvalidOperationException("Column must specify either Property, For parameter, or CellTemplate");
        }
        
        if (ParentTable != null && TableContext?.ItemType != null)
        {
            var columnDef = CreateColumnDefinition();
            if (columnDef != null)
            {
                ParentTable.AddColumn(columnDef);
            }
        }
        
        base.OnInitialized();
    }
    
    private object CreateColumnDefinition()
    {
        var itemType = TableContext.ItemType;
        
        if (!string.IsNullOrEmpty(Property))
        {
            return CreateColumnFromProperty(Property, itemType);
        }
        
        if (For != null)
        {
            return CreateColumnFromLambda(For, itemType);
        }
        
        if (CellTemplate != null || ChildContent != null)
        {
            return CreateColumnFromTemplate(itemType);
        }
        
        throw new InvalidOperationException("Column must specify either Property, For parameter, or CellTemplate");
    }
    
    private object CreateColumnFromProperty(string propertyName, Type itemType)
    {
        var columnDefType = typeof(ColumnDefinition<>).MakeGenericType(itemType);
        var columnDef = Activator.CreateInstance(columnDefType);
        
        SetColumnProperties(columnDef, propertyName);
        
        // Create property expression for value access
        var propertyInfo = itemType.GetProperty(propertyName);
        if (propertyInfo != null)
        {
            var parameter = Expression.Parameter(itemType, "x");
            var propertyAccess = Expression.Property(parameter, propertyInfo);
            var conversion = Expression.Convert(propertyAccess, typeof(object));
            var lambda = Expression.Lambda(conversion, parameter);
            
            SetProperty(columnDefType, columnDef, "Property", lambda);
        }
        
        return columnDef;
    }
    
    private object CreateColumnFromLambda(object lambda, Type itemType)
    {
        var columnDefType = typeof(ColumnDefinition<>).MakeGenericType(itemType);
        var columnDef = Activator.CreateInstance(columnDefType);
        
        var propertyName = ExtractPropertyName(lambda);
        SetColumnProperties(columnDef, propertyName);
        
        if (lambda is LambdaExpression lambdaExpr)
        {
            var param = lambdaExpr.Parameters[0];
            var body = lambdaExpr.Body.Type == typeof(object) 
                ? lambdaExpr.Body 
                : Expression.Convert(lambdaExpr.Body, typeof(object));
                
            var typedLambda = Expression.Lambda(body, param);
            SetProperty(columnDefType, columnDef, "Property", typedLambda);
        }
        
        return columnDef;
    }
    
    private object CreateColumnFromTemplate(Type itemType)
    {
        var columnDefType = typeof(ColumnDefinition<>).MakeGenericType(itemType);
        var columnDef = Activator.CreateInstance(columnDefType);
        
        // Use Header as the property name for template-only columns
        var propertyName = Header ?? "Column";
        SetColumnProperties(columnDef, propertyName);
        
        // No Property accessor needed for template-only columns
        
        return columnDef;
    }
    
    private void SetColumnProperties(object columnDef, string propertyName)
    {
        var type = columnDef.GetType();
        
        SetProperty(type, columnDef, "Title", Header ?? Title ?? propertyName);
        SetProperty(type, columnDef, "Key", propertyName);
        SetProperty(type, columnDef, "Sortable", Sortable ?? true);
        SetProperty(type, columnDef, "Filterable", Filterable ?? false);
        SetProperty(type, columnDef, "Searchable", Searchable ?? true);
        SetProperty(type, columnDef, "Width", Width);
        SetProperty(type, columnDef, "MinWidth", MinWidth);
        SetProperty(type, columnDef, "MaxWidth", MaxWidth);
        SetProperty(type, columnDef, "Format", Format);
        SetProperty(type, columnDef, "EmptyText", EmptyText ?? "-");
        SetProperty(type, columnDef, "Order", Order);
        SetProperty(type, columnDef, "Visible", Visible);
        SetProperty(type, columnDef, "Class", Class);
        SetProperty(type, columnDef, "HeaderClass", HeaderClass);
        SetProperty(type, columnDef, "CellClass", CellClass);
        
        // Auto-detect Template based on CellTemplate/ChildContent
        var effectiveTemplate = Template;
        if (CellTemplate != null || ChildContent != null)
        {
            effectiveTemplate = ColumnTemplate.Custom;
        }
        SetProperty(type, columnDef, "Template", effectiveTemplate);
        
        if (CellTemplate != null)
        {
            // Convert RenderFragment<object> to RenderFragment<TItem>
            var itemType = TableContext.ItemType;
            var templateType = typeof(RenderFragment<>).MakeGenericType(itemType);
            var convertedTemplate = ConvertTemplate(CellTemplate, itemType);
            SetProperty(type, columnDef, "CustomTemplate", convertedTemplate);
        }
        else if (ChildContent != null)
        {
            // Convert RenderFragment to RenderFragment<TItem>  
            var itemType = TableContext.ItemType;
            var templateType = typeof(RenderFragment<>).MakeGenericType(itemType);
            var convertedTemplate = ConvertChildContentTemplate(ChildContent, itemType);
            SetProperty(type, columnDef, "CustomTemplate", convertedTemplate);
        }
    }
    
    private void SetProperty(Type type, object obj, string propertyName, object value)
    {
        var property = type.GetProperty(propertyName);
        if (property != null && property.CanWrite)
        {
            try
            {
                property.SetValue(obj, value);
            }
            catch
            {
                // Ignore property setting errors for compatibility
            }
        }
    }
    
    private string ExtractPropertyName(object lambda)
    {
        try
        {
            if (lambda is LambdaExpression lambdaExpr)
            {
                return lambdaExpr.Body switch
                {
                    MemberExpression member => member.Member.Name,
                    UnaryExpression { Operand: MemberExpression member } => member.Member.Name,
                    _ => "Column"
                };
            }
            return "Column";
        }
        catch
        {
            return "Column";
        }
    }
    
    private object ConvertTemplate(RenderFragment<object> template, Type itemType)
    {
        // Create RenderFragment<TItem> that casts the item to object and calls the original template
        var delegateType = typeof(RenderFragment<>).MakeGenericType(itemType);
        
        // Use dynamic to create the generic RenderFragment<TItem>
        dynamic convertedTemplate = CreateGenericRenderFragment(template, itemType);
        return convertedTemplate;
    }
    
    private object ConvertChildContentTemplate(RenderFragment content, Type itemType)
    {
        // Create RenderFragment<TItem> that ignores the item and renders the ChildContent
        var delegateType = typeof(RenderFragment<>).MakeGenericType(itemType);
        
        // Use dynamic to create the generic RenderFragment<TItem>
        dynamic convertedTemplate = CreateGenericRenderFragmentFromChildContent(content, itemType);
        return convertedTemplate;
    }
    
    private object CreateGenericRenderFragment(RenderFragment<object> template, Type itemType)
    {
        // Create a method that takes TItem and renders with the template
        var method = GetType().GetMethod(nameof(GenericTemplateRenderer), BindingFlags.NonPublic | BindingFlags.Instance);
        var genericMethod = method.MakeGenericMethod(itemType);
        
        return genericMethod.Invoke(this, new object[] { template });
    }
    
    private object CreateGenericRenderFragmentFromChildContent(RenderFragment content, Type itemType)
    {
        // Create a method that ignores TItem and renders ChildContent
        var method = GetType().GetMethod(nameof(GenericChildContentRenderer), BindingFlags.NonPublic | BindingFlags.Instance);
        var genericMethod = method.MakeGenericMethod(itemType);
        
        return genericMethod.Invoke(this, new object[] { content });
    }
    
    private RenderFragment<T> GenericTemplateRenderer<T>(RenderFragment<object> template)
    {
        return item => template((object)item);
    }
    
    private RenderFragment<T> GenericChildContentRenderer<T>(RenderFragment content)
    {
        return item => content;
    }
}