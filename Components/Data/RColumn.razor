@using RR.Blazor.Models
@using System.Linq.Expressions
@inherits RColumnBase

@code {
    [CascadingParameter] public ITableParent ParentTable { get; set; }
    [CascadingParameter] public TableContext TableContext { get; set; }
    
    [Parameter] public object For { get; set; }
    [Parameter] public string Property { get; set; }
    [Parameter] public RenderFragment ChildContent { get; set; }
    [Parameter] public RenderFragment<object> CellTemplate { get; set; }
    
    protected override void OnInitialized()
    {
        // Validate required parameters
        if (string.IsNullOrEmpty(Property) && For == null)
        {
            throw new InvalidOperationException("Column must specify either Property or For parameter");
        }
        
        if (ParentTable != null && TableContext?.ItemType != null)
        {
            var columnDef = CreateColumnDefinition();
            if (columnDef != null)
            {
                ParentTable.AddColumn(columnDef);
            }
        }
        
        base.OnInitialized();
    }
    
    private object CreateColumnDefinition()
    {
        var itemType = TableContext.ItemType;
        
        if (!string.IsNullOrEmpty(Property))
        {
            return CreateColumnFromProperty(Property, itemType);
        }
        
        if (For != null)
        {
            return CreateColumnFromLambda(For, itemType);
        }
        
        throw new InvalidOperationException("Column must specify either Property or For parameter");
    }
    
    private object CreateColumnFromProperty(string propertyName, Type itemType)
    {
        var columnDefType = typeof(ColumnDefinition<>).MakeGenericType(itemType);
        var columnDef = Activator.CreateInstance(columnDefType);
        
        SetColumnProperties(columnDef, propertyName);
        return columnDef;
    }
    
    private object CreateColumnFromLambda(object lambda, Type itemType)
    {
        var columnDefType = typeof(ColumnDefinition<>).MakeGenericType(itemType);
        var columnDef = Activator.CreateInstance(columnDefType);
        
        var propertyName = ExtractPropertyName(lambda);
        SetColumnProperties(columnDef, propertyName);
        
        return columnDef;
    }
    
    private void SetColumnProperties(object columnDef, string propertyName)
    {
        var type = columnDef.GetType();
        
        SetProperty(type, columnDef, "Title", Header ?? Title ?? propertyName);
        SetProperty(type, columnDef, "Key", propertyName);
        SetProperty(type, columnDef, "Sortable", Sortable ?? true);
        SetProperty(type, columnDef, "Searchable", Searchable ?? true);
        SetProperty(type, columnDef, "Width", Width);
        SetProperty(type, columnDef, "MinWidth", MinWidth);
        SetProperty(type, columnDef, "MaxWidth", MaxWidth);
        SetProperty(type, columnDef, "Format", Format);
        SetProperty(type, columnDef, "EmptyText", EmptyText ?? "-");
        SetProperty(type, columnDef, "Order", Order);
        SetProperty(type, columnDef, "Visible", Visible);
        SetProperty(type, columnDef, "Class", Class);
        SetProperty(type, columnDef, "HeaderClass", HeaderClass);
        SetProperty(type, columnDef, "CellClass", CellClass);
        
        if (CellTemplate != null)
        {
            SetProperty(type, columnDef, "CustomTemplate", CellTemplate);
        }
        else if (ChildContent != null)
        {
            var template = new RenderFragment<object>(context => ChildContent);
            SetProperty(type, columnDef, "CustomTemplate", template);
        }
    }
    
    private void SetProperty(Type type, object obj, string propertyName, object value)
    {
        var property = type.GetProperty(propertyName);
        if (property != null && property.CanWrite)
        {
            try
            {
                property.SetValue(obj, value);
            }
            catch
            {
                // Ignore property setting errors for compatibility
            }
        }
    }
    
    private string ExtractPropertyName(object lambda)
    {
        try
        {
            if (lambda is LambdaExpression lambdaExpr)
            {
                return lambdaExpr.Body switch
                {
                    MemberExpression member => member.Member.Name,
                    UnaryExpression { Operand: MemberExpression member } => member.Member.Name,
                    _ => "Column"
                };
            }
            return "Column";
        }
        catch
        {
            return "Column";
        }
    }
}