@using RR.Blazor.Components.Form
@using RR.Blazor.Components.Base
@using RR.Blazor.Enums
@using RR.Blazor.Models
@inherits RComponentBase

<RChoiceGeneric TValue="@string"
                Items="@(new[] { "manage" })"
                EffectiveVariant="ChoiceVariant.Dropdown"
                Density="DensityType.Dense"
                CloseOnSelect="false">
    <TriggerContent>
        <div class="d-flex items-center justify-center" title="Manage Columns">
            <i class="icon">view_column</i>
        </div>
    </TriggerContent>
    
    <ItemTemplate Context="item">
        <div class="min-w-md max-w-lg" data-column-manager="true" @onclick:stopPropagation="true">
            <div class="p-4 border-b border-surface-outline">
                <div class="text-h6 font-semibold">Manage Columns</div>
                <p class="text-sm text-secondary">Show, hide, resize, and reorder table columns</p>
            </div>
            
            <div class="max-h-80 overflow-y-auto">
                @foreach (var column in GetSortedColumns())
                {
                    <div class="p-3 border-b border-surface-outline/50 hover:bg-surface-elevated transition-all duration-200 @(draggedColumn?.Key == column.Key ? "opacity-50" : "")" 
                         data-column-row="@column.Key"
                         draggable="@EnableReordering.ToString().ToLower()"
                         @ondragstart="@(async () => await OnDragStart(column))"
                         @ondragend="@(async () => await OnDragEnd())"
                         @ondragenter="@(async () => await OnDragEnter(column))"
                         @ondragover="@(async (e) => await OnDragOver(e, column))"
                         @ondragover:preventDefault="true"
                         @ondrop="@(async () => await OnDrop(column))"
                         @ondrop:preventDefault="true">
                        <div class="d-flex items-center justify-between gap-3">
                            <div class="d-flex items-center gap-2 flex-1">
                                @if (EnableReordering)
                                {
                                    <i class="icon text-muted cursor-move" title="Drag to reorder">drag_indicator</i>
                                }
                                <div class="flex-1">
                                    <div class="font-medium text-sm">@column.Title</div>
                                    @if (!string.IsNullOrEmpty(column.Width) || IsColumnPinned(column.Key))
                                    {
                                        <div class="text-xs  text-muted mt-1 d-flex gap-2">
                                            @if (!string.IsNullOrEmpty(column.Width))
                                            {
                                                <span>@column.Width</span>
                                            }
                                            @if (IsColumnPinned(column.Key))
                                            {
                                                <span class="text-primary">Pinned @GetPinPosition(column.Key)</span>
                                            }
                                        </div>
                                    }
                                </div>
                            </div>
                            
                            <div class="d-flex items-center gap-2">
                                <input type="checkbox"
                                       class="w-4 h-4"
                                       checked="@IsColumnVisible(column.Key)"
                                       @onchange="@(async (e) => await ToggleColumnVisibility(column.Key, (bool)e.Value!))"
                                       @onclick:stopPropagation="true"
                                       title="Show/Hide Column" />
                                
                                @if (SupportsStickyColumns)
                                {
                                    <button class="p-1 rounded hover:bg-surface-elevated transition-colors @(IsColumnPinned(column.Key) ? "text-primary" : "text-muted")"
                                            @onclick="@(() => ToggleColumnPin(column.Key))"
                                            @onclick:stopPropagation="true"
                                            title="Pin/Unpin Column">
                                        <i class="icon text-base">push_pin</i>
                                    </button>
                                }
                            </div>
                        </div>
                    </div>
                }
            </div>
            
            <div class="p-4 border-t border-surface-outline">
                <div class="d-flex justify-between gap-2">
                    <button class="px-3 py-2 text-sm  text-muted hover:text-primary transition-colors"
                            @onclick="ResetToDefaults"
                            @onclick:stopPropagation="true">
                        Reset to Defaults
                    </button>
                    <button class="px-4 py-2 bg-primary text-primary-contrast rounded text-sm font-medium hover:bg-primary-dark transition-colors"
                            @onclick="SavePreferences"
                            @onclick:stopPropagation="true">
                        Save
                    </button>
                </div>
            </div>
        </div>
    </ItemTemplate>
</RChoiceGeneric>

@code {
    [Parameter] public object Columns { get; set; } = new List<object>();
    [Parameter] public Dictionary<string, ColumnPreferences> Preferences { get; set; } = new();
    [Parameter] public EventCallback<Dictionary<string, ColumnPreferences>> PreferencesChanged { get; set; }
    [Parameter] public EventCallback<ColumnManagementEventArgs> OnColumnManagement { get; set; }
    [Parameter] public bool EnableReordering { get; set; }
    [Parameter] public bool SupportsStickyColumns { get; set; } = true;
    [Parameter] public string TableId { get; set; } = "";
    
    private dynamic draggedColumn;
    private dynamic dragOverColumn;
    
    private List<dynamic> GetSortedColumns()
    {
        if (Columns is IEnumerable<object> columnList)
        {
            return columnList.Cast<dynamic>()
                .OrderBy(c => Preferences.GetValueOrDefault(c.Key as string)?.Order ?? c.Order)
                .ToList();
        }
        return new List<dynamic>();
    }
    
    private async Task OnDragStart(dynamic column)
    {
        draggedColumn = column;
        dragOverColumn = null;
        await InvokeAsync(StateHasChanged);
    }
    
    private async Task OnDragEnd()
    {
        if (draggedColumn != null)
        {
            draggedColumn = null;
            dragOverColumn = null;
            
            // Persist the final order
            await PreferencesChanged.InvokeAsync(Preferences);
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private async Task OnDragEnter(dynamic column)
    {
        if (draggedColumn == null || draggedColumn.Key == column.Key) 
            return;
            
        var columns = GetSortedColumns();
        var draggedIndex = columns.FindIndex(c => c.Key == draggedColumn.Key);
        var targetIndex = columns.FindIndex(c => c.Key == column.Key);
        
        if (draggedIndex < 0 || targetIndex < 0) 
            return;
        
        var reorderedColumns = new List<dynamic>(columns);
        var draggedItem = reorderedColumns[draggedIndex];
        reorderedColumns.RemoveAt(draggedIndex);
        reorderedColumns.Insert(targetIndex, draggedItem);
        
        for (int i = 0; i < reorderedColumns.Count; i++)
        {
            var columnKey = reorderedColumns[i].Key as string;
            if (!string.IsNullOrEmpty(columnKey))
            {
                var prefs = Preferences.GetValueOrDefault(columnKey) ?? new ColumnPreferences();
                Preferences[columnKey] = prefs with { Order = i };
            }
        }
        
        dragOverColumn = column;
        await PreferencesChanged.InvokeAsync(Preferences);
        await InvokeAsync(StateHasChanged);
    }
    
    private async Task OnDragOver(DragEventArgs e, dynamic column)
    {
        if (draggedColumn != null && draggedColumn.Key != column.Key)
        {
            e.DataTransfer.DropEffect = "move";
        }
        await Task.CompletedTask;
    }
    
    private async Task OnDrop(dynamic targetColumn)
    {
        if (draggedColumn == null) 
        {
            return;
        }
        
        // Final cleanup and notification
        var draggedKey = draggedColumn.Key as string;
        
        await OnColumnManagement.InvokeAsync(new ColumnManagementEventArgs
        {
            ColumnKey = draggedKey,
            Action = ColumnManagementAction.Reorder,
            NewValue = Preferences.GetValueOrDefault(draggedKey)?.Order,
            OldValue = 0
        });
        
        draggedColumn = null;
        dragOverColumn = null;
        
        await PreferencesChanged.InvokeAsync(Preferences);
        await InvokeAsync(StateHasChanged);
    }
    
    private bool IsColumnVisible(string columnKey)
    {
        return Preferences.GetValueOrDefault(columnKey)?.Visible ?? true;
    }
    
    private bool IsColumnPinned(string columnKey)
    {
        return Preferences.GetValueOrDefault(columnKey)?.IsPinned ?? false;
    }
    
    private string GetPinPosition(string columnKey)
    {
        var prefs = Preferences.GetValueOrDefault(columnKey);
        return prefs?.PinPosition.ToString() ?? "Left";
    }
    
    private async Task ToggleColumnVisibility(string columnKey, bool visible)
    {
        var currentPrefs = Preferences.GetValueOrDefault(columnKey) ?? new ColumnPreferences();
        
        if (currentPrefs.Visible == visible) return;
        
        var newPrefs = currentPrefs with { Visible = visible };
        Preferences[columnKey] = newPrefs;
        
        await PreferencesChanged.InvokeAsync(Preferences);
        await OnColumnManagement.InvokeAsync(new ColumnManagementEventArgs
        {
            ColumnKey = columnKey,
            Action = visible ? ColumnManagementAction.Show : ColumnManagementAction.Hide,
            NewValue = visible,
            OldValue = currentPrefs.Visible
        });
        
        await InvokeAsync(StateHasChanged);
    }
    
    private async Task ToggleColumnPin(string columnKey)
    {
        var currentPrefs = Preferences.GetValueOrDefault(columnKey) ?? new ColumnPreferences();
        var isPinned = !currentPrefs.IsPinned;
        var newPrefs = currentPrefs with { IsPinned = isPinned };
        Preferences[columnKey] = newPrefs;
        
        await PreferencesChanged.InvokeAsync(Preferences);
        await OnColumnManagement.InvokeAsync(new ColumnManagementEventArgs
        {
            ColumnKey = columnKey,
            Action = isPinned ? ColumnManagementAction.Pin : ColumnManagementAction.Unpin,
            NewValue = isPinned,
            OldValue = currentPrefs.IsPinned
        });
    }
    
    private async Task ResetToDefaults()
    {
        Preferences.Clear();
        await PreferencesChanged.InvokeAsync(Preferences);
        
        if (!string.IsNullOrEmpty(TableId))
        {
            await SafeInvokeAsync("localStorage.removeItem", $"table-preferences-{TableId}");
        }
    }
    
    private async Task SavePreferences()
    {
        if (!string.IsNullOrEmpty(TableId))
        {
            await SafeInvokeAsync("RTableColumnManager.saveColumnPreferences", TableId, Preferences);
        }
    }
}