@namespace RR.Blazor.Components
@using RR.Blazor.Enums
@using RR.Blazor.Attributes
@using RR.Blazor.Components.Base
@using RR.Blazor.Utilities
@inherits RSizedComponentBase<SizeType>

@attribute [Component("RChip", Category = "Core", Complexity = ComponentComplexity.Simple)]
@attribute [AIOptimized(Prompt = "Create a chip/badge for status, counts, tags, or filters", 
                       CommonUse = "status indicators, counts, labels, notifications, tags, filters, badges", 
                       AvoidUsage = "Don't use for navigation - use RButton instead")]

<span class="@GetChipClasses()" 
      @onclick="HandleClick"
      @onclick:stopPropagation="true" 
      @attributes="GetForwardedAttributes()">
    
    @if (!string.IsNullOrEmpty(Icon))
    {
        <i class="icon chip-icon">@Icon</i>
    }
    
    @if (!string.IsNullOrEmpty(Text))
    {
        <span class="chip-text">@Text</span>
    }
    
    @if (ChildContent != null)
    {
        @ChildContent
    }
    
    @if (Closeable)
    {
        <button class="chip-close" 
                @onclick="HandleClose" 
                @onclick:stopPropagation="true" 
                aria-label="@($"Remove {Text}")">
            <i class="icon">close</i>
        </button>
    }
    
    @if (ShouldShowPulse())
    {
        <span class="chip-pulse"></span>
    }
</span>

@code {
    [Parameter]
    [AIParameter(Hint = "Badge for counts, Chip for tags/filters, Status for state indicators, Rounded for circular badges", 
                 SuggestedValues = new[] { "Badge", "Chip", "Status", "Rounded", "Minimal" })]
    public ChipStyle StyleVariant { get; set; } = ChipStyle.Chip;
    
    [Parameter]
    [AIParameter(Hint = "Primary for emphasis, Success for positive, Warning for attention, Error for problems", 
                 SuggestedValues = new[] { "Primary", "Secondary", "Success", "Warning", "Error", "Info" })]
    public VariantType Variant { get; set; } = VariantType.Secondary;
    
    
    [Parameter]
    [AIParameter(Hint = "Set to true for interactive chips that perform actions")]
    public bool Clickable { get; set; }
    
    [Parameter]
    [AIParameter(Hint = "Set to true for removable tags and filter chips")]
    public bool Closeable { get; set; }
    
    [Parameter] public bool Selected { get; set; }
    
    [Parameter]
    [AIParameter(Hint = "Shows pulse animation for processing/loading states")]
    public bool ShowPulse { get; set; }
    
    [Parameter] public EventCallback OnClose { get; set; }
    
    [Parameter]
    [AIParameter(Hint = "Visual intensity/prominence level", 
                 SuggestedValues = new[] { "Normal", "Muted", "Bold", "Subtle" })]
    public IntensityType Intensity { get; set; } = IntensityType.Normal;
    
    [Parameter]
    [AIParameter(Hint = "Visual style aesthetic", 
                 SuggestedValues = new[] { "Material", "Glass", "Neumorphism", "Elevated", "Flat", "Neon", "Frosted" })]
    public StyleType StyleEffect { get; set; } = StyleType.Material;

    private string GetChipClasses()
    {
        var classes = new List<string>();
        
        var baseClass = StyleVariant switch
        {
            ChipStyle.Badge => "chip chip-badge",
            ChipStyle.Status => "chip chip-status",
            ChipStyle.Rounded => "chip chip-rounded",
            ChipStyle.Minimal => "chip chip-minimal",
            ChipStyle.Chip => "chip",
            _ => "chip"
        };
        classes.Add(baseClass);
        
        var variantName = Variant.ToString().ToLower();
        var semanticVariant = variantName == "default" ? "primary" : variantName;
        classes.Add($"chip-{semanticVariant}");
        if (ShouldShowPulse()) classes.Add("chip-pulsing");
        
        var sizeClasses = SizeHelper.GetChipSize(Size, Density);
        classes.Add(sizeClasses);
        
        if (Clickable && !Disabled) classes.Add("chip-clickable");
        if (Selected) classes.Add("chip-selected");
        if (Closeable) classes.Add("chip-closeable");
        if (Disabled) classes.Add("chip-disabled");
        
        classes.Add(GetIntensityClasses());
        classes.Add(GetStyleEffectClasses());
        
        if (!string.IsNullOrEmpty(Class)) classes.Add(Class);
        
        return string.Join(" ", classes);
    }
    
    protected override string GetSizeClasses()
    {
        return Size switch
        {
            SizeType.ExtraSmall => "chip-xs",
            SizeType.Small => "chip-sm",
            SizeType.Medium => "chip-md",
            SizeType.Large => "chip-lg",
            SizeType.ExtraLarge => "chip-xl",
            _ => "chip-md"
        };
    }
    
    protected override SizeType GetDefaultSize() => SizeType.Medium;
    

    private void HandleClick(MouseEventArgs args)
    {
        // Click is handled by parent via @onclick binding when Clickable is true
    }

    private async Task HandleClose()
    {
        if (!Disabled && OnClose.HasDelegate) await OnClose.InvokeAsync();
    }

    private Dictionary<string, object> GetForwardedAttributes()
    {
        var excludeProperties = new HashSet<string>(StringComparer.OrdinalIgnoreCase) 
        { 
            nameof(StyleVariant), nameof(Variant), nameof(Text), nameof(Icon), nameof(Size), 
            nameof(Density), nameof(Clickable), nameof(Closeable), nameof(Selected), 
            nameof(Disabled), nameof(ShowPulse), nameof(OnClick), nameof(OnClose), nameof(ChildContent), 
            nameof(Class), nameof(Title), nameof(Subtitle), nameof(Loading), nameof(LoadingText), 
            nameof(AriaLabel), nameof(TabIndex), nameof(Intensity), nameof(StyleEffect)
        };

        var forwarded = new Dictionary<string, object>();
        var componentType = GetType();
        var properties = componentType.GetProperties()
            .Where(p => p.GetCustomAttributes(typeof(ParameterAttribute), true).Any() 
                       && !excludeProperties.Contains(p.Name)
                       && p.CanRead);

        foreach (var property in properties)
        {
            try
            {
                var value = property.GetValue(this);
                if (value != null || property.PropertyType.IsValueType)
                {
                    forwarded[property.Name] = value;
                }
            }
            catch
            {
                // Skip properties that can't be accessed
            }
        }
        
        return forwarded;
    }

    private bool ShouldShowPulse()
    {
        return (StyleVariant == ChipStyle.Status && Variant == VariantType.Warning) || ShowPulse;
    }
    
    private string GetIntensityClasses()
    {
        return Intensity switch
        {
            IntensityType.Muted => "chip-muted",
            IntensityType.Bold => "chip-bold",
            IntensityType.Subtle => "chip-subtle",
            IntensityType.Normal => "",
            _ => ""
        };
    }
    
    private string GetStyleEffectClasses()
    {
        return StyleEffect switch
        {
            StyleType.Glass => "chip-glass",
            StyleType.Neumorphism => "chip-neumorphism",
            StyleType.Elevated => "chip-elevated",
            StyleType.Flat => "chip-flat",
            StyleType.Neon => "chip-neon",
            StyleType.Frosted => "chip-frosted",
            StyleType.Material => "",
            _ => ""
        };
    }
}